{"language":"Solidity","sources":{"src/Group.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IGroup} from \"./interfaces/IGroup.sol\";\nimport {\n    JoinStatus,\n    ProposalCategory,\n    ExternalMember,\n    GroupData,\n    GroupSettings,\n    ExternalPeriod,\n    ExternalRound,\n    ExternalProposal,\n    NewMemberProposalValue,\n    TransferProposalValue\n} from \"./types/ArisanTypes.sol\";\nimport {ArisanErrors} from \"./errors/ArisanErrors.sol\";\nimport {ArisanMembers} from \"./libraries/ArisanMembers.sol\";\nimport {ArisanPeriods} from \"./libraries/ArisanPeriods.sol\";\nimport {ArisanProposals} from \"./libraries/ArisanProposals.sol\";\nimport {ArisanFinance} from \"./libraries/ArisanFinance.sol\";\nimport {ArisanCapacity} from \"./libraries/ArisanCapacity.sol\";\n\n/// @title Group\n/// @notice Main Arisan group contract managing members, periods, and governance\n/// @dev Uses library pattern for state management and logic separation\n\ncontract Group is IGroup {\n    using ArisanMembers for ArisanMembers.MembersState;\n    using ArisanPeriods for ArisanPeriods.PeriodsState;\n    using ArisanProposals for ArisanProposals.ProposalsState;\n    using ArisanCapacity for ArisanCapacity.CapacityState;\n\n    // ========== Join Mechanism ==========\n\n    /// @notice Whether open join (no approval) is enabled\n    bool public openJoinEnabled;\n\n    /// @notice Mapping to track pending join requests (address -> username)\n    mapping(address => string) private pendingJoinRequests;\n\n    // ========== Platform Configuration ==========\n\n    /// @notice Developer wallet (set from factory)\n    address public platformWallet;\n\n    /// @notice Capacity upgrade cost per tier (immutable from factory)\n    uint256 public capacityUpgradeCost;\n\n    // ========== State Variables ==========\n\n    string public title;\n    string public telegramGroupUrl;\n    address public coordinator;\n    uint256 public coordinatorCommissionPercentage;\n    uint256 public contributionAmountInWei;\n    uint256 public prizePercentage;\n\n    ArisanMembers.MembersState private membersState;\n    ArisanPeriods.PeriodsState private periodsState;\n    ArisanProposals.ProposalsState private proposalsState;\n\n    // Proposal value storage\n    mapping(uint256 => string) private stringProposalValues;\n    mapping(uint256 => uint256) private uintProposalValues;\n    mapping(uint256 => address) private coordinatorProposalValues;\n    mapping(uint256 => NewMemberProposalValue) private newMemberProposalValues;\n    mapping(uint256 => TransferProposalValue) private transferProposalValues;\n    mapping(uint256 => address) private addressProposalValues;\n\n    // ========== Events (additional to interface) ==========\n\n    event ProposalApproved(uint256 indexed proposalIndex, ProposalCategory indexed category);\n    event ProposalRejected(uint256 indexed proposalIndex, ProposalCategory indexed category);\n\n    // ========== Constructor ==========\n\n    /// @notice Initialize a new Arisan group\n    /// @param _title Title of the group\n    /// @param _telegramGroupUrl Telegram group URL\n    /// @param _coordinator Coordinator address\n    /// @param _coordinatorTelegramUsername Coordinator's telegram username\n    /// @param _coordinatorCommissionPercentage Commission percentage for coordinator\n    /// @param _contributionAmountInWei Contribution amount in wei\n    /// @param _prizePercentage Prize percentage for winners\n    constructor(\n        string memory _title,\n        string memory _telegramGroupUrl,\n        address _coordinator,\n        string memory _coordinatorTelegramUsername,\n        uint256 _coordinatorCommissionPercentage,\n        uint256 _contributionAmountInWei,\n        uint256 _prizePercentage\n        // address _platformWallet,\n        // uint256 _capacityUpgradeCost\n    ) {\n        // Validate inputs\n        if (bytes(_title).length == 0) revert ArisanErrors.EmptyTitle();\n        if (bytes(_telegramGroupUrl).length == 0) revert ArisanErrors.EmptyTelegramUrl();\n        if (bytes(_coordinatorTelegramUsername).length == 0)\n            revert ArisanErrors.EmptyCoordinatorUsername();\n        if (_contributionAmountInWei == 0) revert ArisanErrors.InvalidContributionAmount();\n\n        ArisanFinance.validatePercentages(_prizePercentage, _coordinatorCommissionPercentage);\n        ArisanFinance.validateCoordinatorCommission(_coordinatorCommissionPercentage);\n\n        // Set group configuration\n        title = _title;\n        telegramGroupUrl = _telegramGroupUrl;\n        coordinator = _coordinator;\n        coordinatorCommissionPercentage = _coordinatorCommissionPercentage;\n        contributionAmountInWei = _contributionAmountInWei;\n        prizePercentage = _prizePercentage;\n        // platformWallet = _platformWallet;\n        // capacityUpgradeCost = _capacityUpgradeCost;\n        openJoinEnabled = false;\n\n        // Initialize capacity state\n        membersState.capacityState = ArisanCapacity.CapacityState({\n            currentCapacity: ArisanCapacity.INITIAL_CAPACITY,\n            upgradeCount: 0\n        });\n\n        // Add coordinator as first member\n        membersState.addMember(_coordinator, _coordinatorTelegramUsername, true);\n    }\n\n    /// @notice Set platform configuration (only callable once, by factory)\n    function initializePlatformConfig(address _platformWallet, uint256 _capacityUpgradeCost) external {\n        require(platformWallet == address(0), \"Already initialized\");\n        platformWallet = _platformWallet;\n        capacityUpgradeCost = _capacityUpgradeCost;\n    }\n\n    // ========== Coordinator Exclusive Join Setting ======\n    /// @notice Toggle open join setting (coordinator only)\n    /// @param enabled Whether to enable open join\n    function toggleOpenJoin(bool enabled) external coordinatorOnly {\n        openJoinEnabled = enabled;\n        emit OpenJoinToggled(enabled);\n    }\n\n    /// @notice Get current open join status\n    /// @return Whether open join is enabled\n    function isOpenJoinEnabled() external view returns (bool) {\n        return openJoinEnabled;\n    }\n\n    // ========== Modifiers ==========\n\n    modifier coordinatorOnly() {\n        _coordinatorOnly();\n        _;\n    }\n\n    function _coordinatorOnly() internal view {\n        if (msg.sender != coordinator) revert ArisanErrors.NotCoordinator();\n    }\n\n    modifier memberOnly() {\n        _memberOnly();\n        _;\n    }\n\n    function _memberOnly() internal view {\n        if (!membersState.isMember(msg.sender)) revert ArisanErrors.NotMember();\n    }\n\n    modifier activeVoterOnly() {\n        _activeVoterOnly();\n        _;\n    }\n\n    function _activeVoterOnly() internal view {\n        if (!membersState.isActiveVoter(msg.sender)) revert ArisanErrors.NotActiveVoter();\n    }\n\n    modifier ongoingPeriodOnly(uint256 periodIndex) {\n        _ongoingPeriodOnly(periodIndex);\n        _;\n    }\n\n    function _ongoingPeriodOnly(uint256 periodIndex) internal view {\n        if (!periodsState.isPeriodOngoing(periodIndex)) revert ArisanErrors.PeriodEnded();\n    }\n\n    // ========== View Functions: Group Info ==========\n\n    /// @inheritdoc IGroup\n    function getGroupDetail() external view returns (GroupData memory) {\n        JoinStatus joinStatus;\n\n        if (msg.sender == address(0)) {\n            joinStatus = JoinStatus.Unknown;\n        } else if (membersState.isMember(msg.sender)) {\n            joinStatus = JoinStatus.Joined;\n        } else if (_isWaitingForJoinApproval(msg.sender)) {\n            joinStatus = JoinStatus.WaitingApproval;\n        } else {\n            joinStatus = JoinStatus.NotJoined;\n        }\n\n        return GroupData({\n            groupAddress: address(this),\n            title: title,\n            telegramGroupUrl: telegramGroupUrl,\n            membersCount: membersState.getMembersCount(),\n            memberAddresses: membersState.getAllMemberAddresses(),\n            joinStatus: joinStatus\n        });\n    }\n\n    /// @inheritdoc IGroup\n    function getGroupSettings() external view returns (GroupSettings memory) {\n        address coordinatorAddr = coordinator;\n        return GroupSettings({\n            title: title,\n            telegramGroupUrl: telegramGroupUrl,\n            coordinator: ArisanMembers.toExternal(coordinatorAddr, membersState.members[coordinatorAddr]),\n            coordinatorCommissionPercentage: coordinatorCommissionPercentage,\n            contributionAmountInWei: contributionAmountInWei,\n            prizePercentage: prizePercentage,\n            maxCapacity: membersState.capacityState.currentCapacity,\n            capacityUpgradeCount: membersState.capacityState.upgradeCount,\n            openJoinEnabled: openJoinEnabled\n        });\n    }\n\n    // ========== View Functions: Members ==========\n\n    /// @inheritdoc IGroup\n    function getMemberByIndex(uint256 index) external view returns (ExternalMember memory) {\n        (address memberAddr, ) = membersState.getMemberByIndex(index);\n        return ArisanMembers.toExternal(memberAddr, membersState.members[memberAddr]);\n    }\n\n    /// @inheritdoc IGroup\n    function getMembersCount() external view returns (uint256) {\n        return membersState.getMembersCount();\n    }\n\n    /// @inheritdoc IGroup\n    function getActiveVotersCount() external view returns (uint256) {\n        return membersState.getActiveVotersCount();\n    }\n\n    /// @inheritdoc IGroup\n    function getMemberByAddress(address memberAddress) external view returns (ExternalMember memory) {\n        return ArisanMembers.toExternal(memberAddress, membersState.members[memberAddress]);\n    }\n\n    /// @inheritdoc IGroup\n    function isMember(address person) external view returns (bool) {\n        return membersState.isMember(person);\n    }\n\n    // ========== View Functions: Periods ==========\n\n    /// @inheritdoc IGroup\n    function getPeriodsCount() external view returns (uint256) {\n        return periodsState.getPeriodsCount();\n    }\n\n    /// @inheritdoc IGroup\n    function getPeriodByIndex(uint256 index) external view returns (ExternalPeriod memory) {\n        return periodsState.getPeriodByIndex(index);\n    }\n\n    /// @inheritdoc IGroup\n    function getCurrentPeriod() external view returns (ExternalPeriod memory, bool onGoing) {\n        return (ArisanPeriods.toExternal(periodsState.getLastPeriod()), (periodsState.getLastPeriod().endedAt == 0));\n    }\n\n    /// @inheritdoc IGroup\n    function getCurrentPeriodDueWinners() external view returns (address[] memory) {\n        return periodsState.getLastPeriod().dueWinners;\n    }\n\n    /// @inheritdoc IGroup\n    function getRoundByIndexAndPeriodIndex(uint256 roundIndex, uint256 periodIndex)\n        external\n        view\n        returns (ExternalRound memory)\n    {\n        return periodsState.getRoundByIndex(periodIndex, roundIndex, membersState);\n    }\n\n    /// @inheritdoc IGroup\n    function getDueWinnerByIndexAndPeriodIndex(uint256 winnerIndex, uint256 periodIndex)\n        external\n        view\n        returns (ExternalMember memory)\n    {\n        address dueWinner =\n            periodsState.getDueWinnerByIndex(periodIndex, winnerIndex);\n        return ArisanMembers.toExternal(dueWinner, membersState.members[dueWinner]);\n    }\n\n    // ========== View Functions: Proposals ==========\n\n    /// @inheritdoc IGroup\n    function hasVotedOnProposal(uint256 proposalIndex, address voter) external view returns (bool) {\n        return proposalsState.hasVoted(proposalIndex, voter);\n    }\n\n    /// @inheritdoc IGroup\n    function getProposalByIndex(uint256 index) external view returns (ExternalProposal memory) {\n        uint256 count = proposalsState.getProposalsCount();\n        if (index > count) revert ArisanErrors.ProposalDoesNotExist();\n\n        return _buildExternalProposal(index);\n    }\n\n    /// @inheritdoc IGroup\n    function getIncompleteProposalsCount() external view returns (uint256) {\n        return proposalsState.getIncompleteProposalsCount();\n    }\n\n    /// @inheritdoc IGroup\n    function getIncompleteProposalByIndex(uint256 index)\n        external\n        view\n        returns (ExternalProposal memory)\n    {\n        uint256 count = proposalsState.getProposalsCount();\n\n        if (index > count) revert ArisanErrors.ProposalDoesNotExist();\n\n        for (uint256 i = 0; i < count; i++) {\n            if (proposalsState.isIncompleteProposal(i)) {\n                if (i == index) {\n                    return _buildExternalProposal(i);\n                }\n            }\n        }\n\n        revert ArisanErrors.ProposalDoesNotExist();\n    }\n\n    /// @inheritdoc IGroup\n    function getApproverByIndexAndProposalIndex(uint256 approverIndex, uint256 proposalIndex)\n        external\n        view\n        returns (ExternalMember memory)\n    {\n        address approver = proposalsState.getApproverByIndex(proposalIndex, approverIndex);\n        return ArisanMembers.toExternal(approver, membersState.members[approver]);\n    }\n\n    // ========== Member Management ==========\n\n    /// @inheritdoc IGroup\n    function proposeNewMember(address memberAddress, string calldata telegramUsername) external memberOnly {\n        if (_isWaitingForJoinApproval(memberAddress)) revert ArisanErrors.AlreadyWaitingForJoinApproval();\n        if (membersState.isMember(memberAddress)) revert ArisanErrors.MemberAlreadyExists();\n        if (membersState.getMembersCount() >= membersState.getMaxCapacity()) revert ArisanErrors.GroupCapacityExceeded();\n\n        uint256 proposalIndex = proposalsState.createProposal(ProposalCategory.NewMember, memberAddress);\n        newMemberProposalValues[proposalIndex] = NewMemberProposalValue({\n            memberAddress: memberAddress,\n            telegramUsername: telegramUsername\n        });\n\n        emit ProposalCreated(proposalIndex, ProposalCategory.NewMember, memberAddress);\n    }\n\n    /// @inheritdoc IGroup\n    function approveNewMemberProposal(uint256 proposalIndex) external activeVoterOnly {\n        if (proposalsState.getProposal(proposalIndex).category != ProposalCategory.NewMember)\n            revert ArisanErrors.InvalidProposalCategory();\n        if (membersState.getMembersCount() >= membersState.getMaxCapacity()) revert ArisanErrors.GroupCapacityExceeded();\n\n        bool isApproved =\n            proposalsState.recordVote(proposalIndex, msg.sender, true, _calculateRequiredApprovals(membersState.getActiveVotersCount()));\n\n        if (isApproved) {\n            NewMemberProposalValue storage newMemberVal = newMemberProposalValues[proposalIndex];\n            bool shouldBeActiveVoter = periodsState.getPeriodsCount() == 0;\n\n            membersState.addMember(newMemberVal.memberAddress, newMemberVal.telegramUsername, shouldBeActiveVoter);\n\n            emit MemberJoined(newMemberVal.memberAddress, newMemberVal.telegramUsername);\n            emit ProposalApproved(proposalIndex, ProposalCategory.NewMember);\n\n            delete newMemberProposalValues[proposalIndex];\n        }\n    }\n\n    /// @inheritdoc IGroup\n    function rejectNewMemberProposal(uint256 proposalIndex) external activeVoterOnly {\n        if (proposalsState.getProposal(proposalIndex).category != ProposalCategory.NewMember)\n            revert ArisanErrors.InvalidProposalCategory();\n\n        proposalsState.rejectProposal(proposalIndex);\n        emit ProposalRejected(proposalIndex, ProposalCategory.NewMember);\n\n        delete newMemberProposalValues[proposalIndex];\n    }\n\n    /// @inheritdoc IGroup\n    function leave() external memberOnly {\n        if (msg.sender == coordinator) revert ArisanErrors.CoordinatorCannotLeave();\n\n        if (periodsState.getPeriodsCount() > 0) {\n            uint256 lastPeriodIndex = periodsState.getPeriodsCount() - 1;\n            bool isParticipating =\n                periodsState.hasParticipated(lastPeriodIndex, msg.sender)\n                && periodsState.isPeriodOngoing(lastPeriodIndex);\n\n            if (isParticipating) revert ArisanErrors.CannotLeaveWhileParticipating();\n        }\n\n        membersState.removeMember(msg.sender);\n        emit MemberLeft(msg.sender);\n    }\n\n    // ========== Period Management ==========\n\n    /// @inheritdoc IGroup\n    function startPeriod() external payable coordinatorOnly {\n        if (periodsState.getPeriodsCount() > 0) {\n            uint256 lastPeriodIndex = periodsState.getPeriodsCount() - 1;\n            if (periodsState.isPeriodOngoing(lastPeriodIndex))\n                revert ArisanErrors.LastPeriodNotEnded();\n        }\n\n        // Get snapshot of all active members at period start\n        address[] memory activeMembers = membersState.getAllMemberAddresses();\n\n        uint256 periodIndex = periodsState.createPeriod(\n            coordinatorCommissionPercentage,\n            contributionAmountInWei,\n            prizePercentage,\n            activeMembers\n        );\n\n        _contribute(periodIndex);\n        emit PeriodStarted(periodIndex, block.timestamp);\n    }\n\n\n    /// @inheritdoc IGroup\n    function contribute(uint256 periodIndex) external payable memberOnly ongoingPeriodOnly(periodIndex) {\n        _contribute(periodIndex);\n    }\n\n    /// @inheritdoc IGroup\n    function drawWinner(uint256 periodIndex) external coordinatorOnly ongoingPeriodOnly(periodIndex) {\n        ArisanPeriods.PeriodsState storage periods = periodsState;\n        ArisanMembers.MembersState storage members = membersState;\n\n        // Get period and validate\n        if (periods.getDueWinners(periodIndex).length == 0) revert ArisanErrors.NoDueWinnersRemaining();\n\n        uint256 roundIndex = periods.periods[periodIndex].rounds.length - 1;\n        uint256 contributorCount = periods.getContributorCount(periodIndex, roundIndex);\n        uint256 expectedContributors = periods.getParticipantCount(periodIndex);\n        \n        if (contributorCount != expectedContributors) revert ArisanErrors.IncompleteRound();\n\n        // Draw winner\n        uint256 dueWinnersLength = periods.getDueWinners(periodIndex).length;\n        uint256 winnerIndex = dueWinnersLength > 1 ? _generateRandomIndex(dueWinnersLength - 1) : 0;\n        address winner = periods.getDueWinnerByIndex(periodIndex, winnerIndex);\n\n        // Register winner\n        periods.registerWinner(periodIndex, roundIndex, winner, block.timestamp);\n\n        // Remove from due winners\n        periods.removeDueWinner(periodIndex, winnerIndex);\n\n        // Calculate and transfer payouts\n        _executeWinnerPayouts(periodIndex, winner, contributorCount);\n        // uint256 totalContributions = periods.periods[periodIndex].contributionAmountInWei * contributorCount;\n        // uint256 prizePayout = ArisanFinance.calculatePrize(totalContributions, prizePercentage);\n        // uint256 commissionPayout = ArisanFinance.calculateCommission(totalContributions, coordinatorCommissionPercentage);\n\n        // Split commission into net and platform fee\n        // (uint256 coordinatorNetPayout, uint256 platformFee) = ArisanFinance.splitCoordinatorCommission(commissionPayout);\n\n        // Transfer payouts\n        // (bool successWinner, ) = payable(winner).call{value: prizePayout}(\"\");\n        // require(successWinner, \"Winner payment failed\");\n        \n        // (bool successCoordinator, ) = payable(coordinator).call{value: coordinatorNetPayout}(\"\");\n        // require(successCoordinator, \"Coordinator payment failed\");\n        \n        // Transfer platform fee\n        // (bool successPlatform, ) = payable(platformWallet).call{value: platformFee}(\"\");\n        // require(successPlatform, \"Platform fee payment failed\");\n\n        // ArisanFinance.transfer(payable(winner), prizePayout);\n        // ArisanFinance.transfer(payable(coordinator), commissionPayout);\n        // ArisanFinance.transfer(payable(platformWallet), platformFee);\n\n        // periods.deductFromBalance(periodIndex, prizePayout + commissionPayout);\n\n        // Create next round or end period\n        if (periods.getDueWinners(periodIndex).length > 0) {\n            periods.createNewRound(periodIndex);\n        } else {\n            _endPeriod(periodIndex);\n        }\n\n        emit WinnerDrawn(ArisanMembers.toExternal(winner, members.members[winner]), periodIndex, roundIndex);\n    }\n\n    /// @notice Helper: Execute all winner payouts\n    function _executeWinnerPayouts(\n        uint256 periodIndex,\n        address winner,\n        uint256 contributorCount\n    ) private {\n        ArisanPeriods.PeriodsState storage periods = periodsState;\n        \n        uint256 totalContributions = periods.periods[periodIndex].contributionAmountInWei * contributorCount;\n        uint256 prizePayout = ArisanFinance.calculatePrize(totalContributions, prizePercentage);\n        uint256 commissionPayout = ArisanFinance.calculateCommission(totalContributions, coordinatorCommissionPercentage);\n        (uint256 coordinatorNetPayout, uint256 platformFee) = ArisanFinance.splitCoordinatorCommission(commissionPayout);\n\n        ArisanFinance.transfer(payable(winner), prizePayout);\n        ArisanFinance.transfer(payable(coordinator), coordinatorNetPayout);\n        ArisanFinance.transfer(payable(platformWallet), platformFee);\n\n        periods.deductFromBalance(periodIndex, prizePayout + commissionPayout);\n    }\n\n    // ========== Governance: String Proposals ==========\n\n    /// @inheritdoc IGroup\n    function proposeKickMember(address memberToKick) external activeVoterOnly {\n        if (memberToKick == coordinator) revert ArisanErrors.CoordinatorCannotLeave();\n        if (!membersState.isMember(memberToKick)) revert ArisanErrors.NotMember();\n        if (memberToKick == msg.sender) revert ArisanErrors.CannotKickSelf();\n\n        uint256 proposalIndex = proposalsState.createProposal(ProposalCategory.KickMember, msg.sender);\n        addressProposalValues[proposalIndex] = memberToKick;\n\n        emit ProposalCreated(proposalIndex, ProposalCategory.KickMember, msg.sender);\n    }\n\n    /// @inheritdoc IGroup\n    function approveKickMemberProposal(uint256 proposalIndex) external activeVoterOnly {\n        if (proposalsState.getProposal(proposalIndex).category != ProposalCategory.KickMember)\n            revert ArisanErrors.InvalidProposalCategory();\n\n        address memberToKick = addressProposalValues[proposalIndex];\n        if (!membersState.isMember(memberToKick)) revert ArisanErrors.NotMember();\n\n        bool isApproved = proposalsState.recordVote(\n            proposalIndex,\n            msg.sender,\n            true,\n            _calculateRequiredApprovals(membersState.getActiveVotersCount())\n        );\n\n        if (isApproved) {\n            uint256 periodIndex = periodsState.getPeriodsCount() - 1;\n\n            if (membersState.getCurrentPeriodParticipationStatus(memberToKick, periodIndex)) {\n                if (periodsState.isPeriodOngoing(periodIndex)) {\n                    periodsState.removeDueWinner(periodIndex, periodsState.getDueWinnerIndexByAddress(periodIndex, memberToKick));\n                }\n            }\n\n            // Remove from member list - NO REFUND\n            membersState.removeMember(memberToKick);\n            emit MemberKicked(memberToKick);\n            delete addressProposalValues[proposalIndex];\n        }\n    }\n\n\n    /// @inheritdoc IGroup\n    function proposeNewTitle(string calldata newValue) external activeVoterOnly {\n        uint256 proposalIndex = proposalsState.createProposal(ProposalCategory.Title, msg.sender);\n        stringProposalValues[proposalIndex] = newValue;\n\n        emit ProposalCreated(proposalIndex, ProposalCategory.Title, msg.sender);\n    }\n\n    /// @inheritdoc IGroup\n    function approveNewTitleProposal(uint256 proposalIndex) external activeVoterOnly {\n        if (proposalsState.getProposal(proposalIndex).category != ProposalCategory.Title)\n            revert ArisanErrors.InvalidProposalCategory();\n\n        bool isApproved = proposalsState.recordVote(\n            proposalIndex, msg.sender, true, _calculateRequiredApprovals(membersState.getActiveVotersCount())\n        );\n\n        if (isApproved) {\n            title = stringProposalValues[proposalIndex];\n            emit ProposalApproved(proposalIndex, ProposalCategory.Title);\n            delete stringProposalValues[proposalIndex];\n        }\n    }\n\n    /// @inheritdoc IGroup\n    function proposeNewTelegramGroupUrl(string calldata newValue) external activeVoterOnly {\n        uint256 proposalIndex = proposalsState.createProposal(ProposalCategory.TelegramGroupUrl, msg.sender);\n        stringProposalValues[proposalIndex] = newValue;\n\n        emit ProposalCreated(proposalIndex, ProposalCategory.TelegramGroupUrl, msg.sender);\n    }\n\n    /// @inheritdoc IGroup\n    function approveNewTelegramGroupUrlProposal(uint256 proposalIndex) external activeVoterOnly {\n        if (proposalsState.getProposal(proposalIndex).category !=\n            ProposalCategory.TelegramGroupUrl) revert ArisanErrors.InvalidProposalCategory();\n\n        bool isApproved = proposalsState.recordVote(\n            proposalIndex, msg.sender, true, _calculateRequiredApprovals(membersState.getActiveVotersCount())\n        );\n\n        if (isApproved) {\n            telegramGroupUrl = stringProposalValues[proposalIndex];\n            emit ProposalApproved(proposalIndex, ProposalCategory.TelegramGroupUrl);\n            delete stringProposalValues[proposalIndex];\n        }\n    }\n\n    /// @inheritdoc IGroup\n    function rejectStringProposal(uint256 proposalIndex) external activeVoterOnly {\n        ProposalCategory category = proposalsState.getProposal(proposalIndex).category;\n        if (category != ProposalCategory.Title && category != ProposalCategory.TelegramGroupUrl)\n            revert ArisanErrors.InvalidProposalCategory();\n\n        proposalsState.rejectProposal(proposalIndex);\n        emit ProposalRejected(proposalIndex, category);\n\n        delete stringProposalValues[proposalIndex];\n    }\n\n    // ========== Governance: Uint Proposals ==========\n\n    /// @inheritdoc IGroup\n    function proposeNewContributionAmountInWei(uint256 newContributionAmountInWei) external activeVoterOnly {\n        if (newContributionAmountInWei == 0) revert ArisanErrors.InvalidContributionAmount();\n\n        uint256 proposalIndex =\n            proposalsState.createProposal(ProposalCategory.ContributionAmount, msg.sender);\n        uintProposalValues[proposalIndex] = newContributionAmountInWei;\n\n        emit ProposalCreated(proposalIndex, ProposalCategory.ContributionAmount, msg.sender);\n    }\n\n    /// @inheritdoc IGroup\n    function approveContributionAmountProposal(uint256 proposalIndex) external activeVoterOnly {\n        if (proposalsState.getProposal(proposalIndex).category !=\n            ProposalCategory.ContributionAmount) revert ArisanErrors.InvalidProposalCategory();\n\n        bool isApproved = proposalsState.recordVote(\n            proposalIndex, msg.sender, true, _calculateRequiredApprovals(membersState.getActiveVotersCount())\n        );\n\n        if (isApproved) {\n            contributionAmountInWei = uintProposalValues[proposalIndex];\n            emit ProposalApproved(proposalIndex, ProposalCategory.ContributionAmount);\n            delete uintProposalValues[proposalIndex];\n        }\n    }\n\n    /// @inheritdoc IGroup\n    function proposeNewPrizePercentage(uint256 newPrizePercentage) external activeVoterOnly {\n        ArisanFinance.validatePercentages(newPrizePercentage, coordinatorCommissionPercentage);\n\n        uint256 proposalIndex =\n            proposalsState.createProposal(ProposalCategory.PrizePercentage, msg.sender);\n        uintProposalValues[proposalIndex] = newPrizePercentage;\n\n        emit ProposalCreated(proposalIndex, ProposalCategory.PrizePercentage, msg.sender);\n    }\n\n    /// @inheritdoc IGroup\n    function approvePrizePercentageProposal(uint256 proposalIndex) external activeVoterOnly {\n        if (proposalsState.getProposal(proposalIndex).category !=\n            ProposalCategory.PrizePercentage) revert ArisanErrors.InvalidProposalCategory();\n\n        bool isApproved = proposalsState.recordVote(\n            proposalIndex, msg.sender, true, _calculateRequiredApprovals(membersState.getActiveVotersCount())\n        );\n\n        if (isApproved) {\n            prizePercentage = uintProposalValues[proposalIndex];\n            emit ProposalApproved(proposalIndex, ProposalCategory.PrizePercentage);\n            delete uintProposalValues[proposalIndex];\n        }\n    }\n\n    /// @inheritdoc IGroup\n    function proposeNewCoordinatorCommissionPercentage(uint256 newCoordinatorCommissionPercentage)\n        external\n        activeVoterOnly\n    {\n        ArisanFinance.validatePercentages(prizePercentage, newCoordinatorCommissionPercentage);\n        ArisanFinance.validateCoordinatorCommission(newCoordinatorCommissionPercentage);\n\n        uint256 proposalIndex = proposalsState.createProposal(\n            ProposalCategory.CoordinatorCommissionPercentage, msg.sender\n        );\n        uintProposalValues[proposalIndex] = newCoordinatorCommissionPercentage;\n\n        emit ProposalCreated(proposalIndex, ProposalCategory.CoordinatorCommissionPercentage, msg.sender);\n    }\n\n    /// @inheritdoc IGroup\n    function approveNewCoordinatorCommissionPercentageProposal(uint256 proposalIndex)\n        external\n        activeVoterOnly\n    {\n        if (proposalsState.getProposal(proposalIndex).category !=\n            ProposalCategory.CoordinatorCommissionPercentage) revert ArisanErrors.InvalidProposalCategory();\n\n        bool isApproved = proposalsState.recordVote(\n            proposalIndex, msg.sender, true, _calculateRequiredApprovals(membersState.getActiveVotersCount())\n        );\n\n        if (isApproved) {\n            coordinatorCommissionPercentage = uintProposalValues[proposalIndex];\n            emit ProposalApproved(proposalIndex, ProposalCategory.CoordinatorCommissionPercentage);\n            delete uintProposalValues[proposalIndex];\n        }\n    }\n\n    /// @inheritdoc IGroup\n    function rejectUintProposal(uint256 proposalIndex) external activeVoterOnly {\n        ProposalCategory category = proposalsState.getProposal(proposalIndex).category;\n        if (category != ProposalCategory.ContributionAmount && category != ProposalCategory.PrizePercentage\n            && category != ProposalCategory.CoordinatorCommissionPercentage)\n            revert ArisanErrors.InvalidProposalCategory();\n\n        proposalsState.rejectProposal(proposalIndex);\n        emit ProposalRejected(proposalIndex, category);\n\n        delete uintProposalValues[proposalIndex];\n    }\n\n    // ========== Governance: Coordinator Proposals ==========\n\n    /// @inheritdoc IGroup\n    function proposeNewCoordinator(address newCoordinator) external activeVoterOnly {\n        if (newCoordinator == address(0)) revert ArisanErrors.InvalidRecipient();\n\n        uint256 proposalIndex =\n            proposalsState.createProposal(ProposalCategory.Coordinator, msg.sender);\n        coordinatorProposalValues[proposalIndex] = newCoordinator;\n\n        emit ProposalCreated(proposalIndex, ProposalCategory.Coordinator, msg.sender);\n    }\n\n    /// @inheritdoc IGroup\n    function approveNewCoordinatorProposal(uint256 proposalIndex) external activeVoterOnly {\n        if (proposalsState.getProposal(proposalIndex).category != ProposalCategory.Coordinator)\n            revert ArisanErrors.InvalidProposalCategory();\n\n        bool isApproved = proposalsState.recordVote(\n            proposalIndex, msg.sender, true, _calculateRequiredApprovals(membersState.getActiveVotersCount())\n        );\n\n        if (isApproved) {\n            coordinator = coordinatorProposalValues[proposalIndex];\n            emit ProposalApproved(proposalIndex, ProposalCategory.Coordinator);\n            delete coordinatorProposalValues[proposalIndex];\n        }\n    }\n\n    /// @inheritdoc IGroup\n    function rejectNewCoordinatorProposal(uint256 proposalIndex) external activeVoterOnly {\n        if (proposalsState.getProposal(proposalIndex).category != ProposalCategory.Coordinator)\n            revert ArisanErrors.InvalidProposalCategory();\n\n        proposalsState.rejectProposal(proposalIndex);\n        emit ProposalRejected(proposalIndex, ProposalCategory.Coordinator);\n\n        delete coordinatorProposalValues[proposalIndex];\n    }\n\n    // ========== Governance: Transfer Proposals ==========\n\n    /// @inheritdoc IGroup\n    function proposeTransfer(address recipient, uint256 transferAmount) external activeVoterOnly {\n        if (recipient == address(0)) revert ArisanErrors.InvalidRecipient();\n        if (transferAmount == 0) revert ArisanErrors.AmountIsZero();\n\n        uint256 lockedBalance = _getLockedBalance();\n\n        if (!ArisanFinance.hasSufficientBalance(address(this).balance, lockedBalance, transferAmount)) {\n            revert ArisanErrors.InsufficientBalance();\n        }\n\n        uint256 proposalIndex = proposalsState.createProposal(ProposalCategory.Transfer, msg.sender);\n        transferProposalValues[proposalIndex] = TransferProposalValue({\n            recipient: payable(recipient),\n            transferAmount: transferAmount\n        });\n\n        emit ProposalCreated(proposalIndex, ProposalCategory.Transfer, msg.sender);\n    }\n\n    /// @inheritdoc IGroup\n    function approveTransferProposal(uint256 proposalIndex) external activeVoterOnly {\n        if (proposalsState.getProposal(proposalIndex).category != ProposalCategory.Transfer)\n            revert ArisanErrors.InvalidProposalCategory();\n\n        // Revalidate balance before approval\n        uint256 lockedBalance = _getLockedBalance();\n        uint256 transferAmount = transferProposalValues[proposalIndex].transferAmount;\n        if (!ArisanFinance.hasSufficientBalance(address(this).balance, lockedBalance, transferAmount)) {\n            revert ArisanErrors.InsufficientBalance();\n        }\n\n        bool isApproved = proposalsState.recordVote(\n            proposalIndex, msg.sender, true, _calculateRequiredApprovals(membersState.getActiveVotersCount())\n        );\n\n        if (isApproved) {\n            ArisanFinance.transfer(\n                transferProposalValues[proposalIndex].recipient,\n                transferProposalValues[proposalIndex].transferAmount\n            );\n\n            emit TransferExecuted(\n                transferProposalValues[proposalIndex].recipient, transferProposalValues[proposalIndex].transferAmount\n            );\n            emit ProposalApproved(proposalIndex, ProposalCategory.Transfer);\n\n            delete transferProposalValues[proposalIndex];\n        }\n    }\n\n    /// @inheritdoc IGroup\n    function rejectTransferProposal(uint256 proposalIndex) external activeVoterOnly {\n        if (proposalsState.getProposal(proposalIndex).category != ProposalCategory.Transfer)\n            revert ArisanErrors.InvalidProposalCategory();\n\n        proposalsState.rejectProposal(proposalIndex);\n        emit ProposalRejected(proposalIndex, ProposalCategory.Transfer);\n\n        delete transferProposalValues[proposalIndex];\n    }\n\n    // ========== Internal Functions ==========\n\n    /// @notice calculate required approvals for proposals (CHANGE HERE)\n    /// @param activeVoters amount of active voters\n    function _calculateRequiredApprovals(uint256 activeVoters) private pure returns (uint256) {\n        if (activeVoters == 0) return 1;\n        return (activeVoters / 2) + 1;\n    }\n\n\n    /// @notice Contribute to a period (internal helper)\n    /// @param periodIndex Index of the period\n    function _contribute(uint256 periodIndex) internal {\n        if (!membersState.isMember(msg.sender)) revert ArisanErrors.NotMember();\n        if (!periodsState.isPeriodOngoing(periodIndex))\n            revert ArisanErrors.PeriodEnded();\n\n        ArisanPeriods.PeriodsState storage periods = periodsState;\n        uint256 currentRoundCount = periods.periods[periodIndex].rounds.length;\n        uint256 previousParticipationCount =\n            periods.getParticipationCount(periodIndex, msg.sender);\n        uint256 roundsSinceLast = currentRoundCount - previousParticipationCount;\n\n        if (roundsSinceLast != 1) revert ArisanErrors.DidNotParticipateInPreviousRound();\n\n        uint256 requiredContribution =\n            ArisanFinance.calculateContributionAmount(contributionAmountInWei, roundsSinceLast);\n        if (msg.value != requiredContribution) revert ArisanErrors.IncorrectContributionAmount();\n\n        // Record contribution\n        periods.recordContribution(periodIndex, msg.sender, msg.value);\n\n        // Update member status\n        membersState.updateLatestPeriodParticipation(msg.sender, periodIndex);\n        if (!membersState.isActiveVoter(msg.sender)) {\n            membersState.setActiveVoter(msg.sender);\n        }\n    }\n\n    /// @notice End a period and remove inactive voters\n    /// @param periodIndex Index of the period\n    function _endPeriod(uint256 periodIndex) private {\n        if (proposalsState.getIncompleteProposalsCount() > 0) {\n            revert ArisanErrors.IncompleteProposalsRemaining();\n        }\n\n        periodsState.endPeriod(periodIndex);\n        // _removeInactiveVoters();\n\n        emit PeriodEnded(periodIndex, block.timestamp);\n    }\n\n    /// @notice Remove voting rights from inactive members\n    // function _removeInactiveVoters() private {\n    //     uint256 periodsCount = periodsState.getPeriodsCount();\n\n    //     if (periodsCount >= 2) {\n    //         uint256 checkIndex = periodsCount - 2;\n    //         address[] memory participants = periodsState.getDueWinners(checkIndex);\n\n    //         for (uint256 i = 0; i < participants.length; i++) {\n    //             address participant = participants[i];\n    //             if (membersState.members[participant].latestPeriodParticipation <= checkIndex) {\n    //                 membersState.setInactiveVoter(participant);\n    //             }\n    //         }\n    //     }\n    // }\n\n    /// @notice Check if sender is waiting for join approval\n    /// @param account Address to check\n    /// @return True if waiting for approval\n    function _isWaitingForJoinApproval(address account) private view returns (bool) {\n        for (uint256 i = 0; i < proposalsState.getProposalsCount(); i++) {\n            if (proposalsState.isIncompleteProposal(i)) {\n                if (proposalsState.getProposal(i).category == ProposalCategory.NewMember) {\n                    if (newMemberProposalValues[i].memberAddress == account) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    /// @notice Get locked balance (balance in ongoing period)\n    /// @return Locked balance amount\n    function _getLockedBalance() private view returns (uint256) {\n        if (periodsState.getPeriodsCount() == 0) return 0;\n\n        uint256 lastPeriodIndex = periodsState.getPeriodsCount() - 1;\n        if (!periodsState.isPeriodOngoing(lastPeriodIndex)) return 0;\n\n        return periodsState.periods[lastPeriodIndex].remainingPeriodBalanceInWei;\n    }\n\n    /// @notice Generate a pseudorandom number\n    /// @param max Upper bound (exclusive)\n    /// @return Random number between 0 and max-1\n    function _generateRandomIndex(uint256 max) private view returns (uint256) {\n        if (max == 0) return 0;\n        return uint256(keccak256(abi.encodePacked(block.timestamp, block.prevrandao))) % max;\n    }\n\n    /// @notice Build external proposal from internal storage\n    /// @param proposalIndex Index of the proposal\n    /// @return External proposal representation\n    function _buildExternalProposal(uint256 proposalIndex)\n        private\n        view\n        returns (ExternalProposal memory)\n    {\n        ArisanProposals.ProposalsState storage proposals = proposalsState;\n        ArisanMembers.MembersState storage members = membersState;\n\n        return ExternalProposal({\n            index: proposalIndex,\n            category: proposals.getProposal(proposalIndex).category,\n            proposedAt: proposals.getProposal(proposalIndex).proposedAt,\n            proposer: ArisanMembers.toExternal(\n                proposals.getProposal(proposalIndex).proposer,\n                members.members[proposals.getProposal(proposalIndex).proposer]\n            ),\n            completedAt: proposals.getProposal(proposalIndex).completedAt,\n            isApproved: proposals.getProposal(proposalIndex).isApproved,\n            approversCount: proposals.getApproversCount(proposalIndex),\n            stringProposalValue: stringProposalValues[proposalIndex],\n            uintProposalValue: uintProposalValues[proposalIndex],\n            coordinatorProposalValue: ArisanMembers.toExternal(\n                coordinatorProposalValues[proposalIndex],\n                members.members[coordinatorProposalValues[proposalIndex]]\n            ),\n            newMemberProposalValue: newMemberProposalValues[proposalIndex],\n            transferProposalValue: transferProposalValues[proposalIndex]\n        });\n    }\n\n    /// @notice Upgrade group capacity to next tier (coordinator only)\n    /// @dev Payment must be exact - no refunds for excess\n    function upgradeCapacity() external payable {\n        if (msg.sender != coordinator) {\n            revert ArisanErrors.NotCoordinator();\n        }\n        \n        if (msg.value != capacityUpgradeCost) {\n            revert ArisanErrors.IncorrectCapacityUpgradePayment();\n        }\n        \n        if (!ArisanCapacity.canUpgrade(\n            membersState.capacityState.currentCapacity,\n            membersState.memberAddresses.length\n        )) {\n            revert ArisanErrors.CannotUpgradeAtCurrentMemberCount();\n        }\n        \n        // Perform upgrade\n        uint256 oldCapacity = membersState.capacityState.currentCapacity;\n        ArisanCapacity.performUpgrade(\n            membersState.capacityState,\n            membersState.memberAddresses.length\n        );\n        uint256 newCapacity = membersState.capacityState.currentCapacity;\n        \n        // Send payment to platform wallet\n        ArisanFinance.transfer(payable(platformWallet), msg.value);\n        // (bool success, ) = payable(platformWallet).call{value: msg.value}(\"\");\n        // require(success, \"Platform payment failed\");\n        \n        emit CapacityUpgraded(oldCapacity, newCapacity, msg.value);\n    }\n\n    /// @notice Get current group capacity limit\n    function getMaxCapacity() external view returns (uint256) {\n        return membersState.capacityState.currentCapacity;\n    }\n\n    /// @notice Get available member slots\n    function getAvailableCapacity() external view returns (uint256) {\n        return ArisanCapacity.getAvailableCapacity(\n            membersState.capacityState,\n            membersState.memberAddresses.length\n        );\n    }\n\n    /// @notice Get total capacity upgrades performed\n    function getCapacityUpgradeCount() external view returns (uint256) {\n        return membersState.capacityState.upgradeCount;\n    }\n\n    /// @notice Get next capacity tier after upgrade\n    function getNextCapacityTier() external view returns (uint256) {\n        return ArisanCapacity.getNextCapacity(membersState.capacityState.currentCapacity);\n    }\n\n    /// @notice Request to join the group with member approval\n    /// @param telegramUsername Telegram username of applicant\n    /// @dev Requires approval from at least 50% of active members\n    function joinGroup(string calldata telegramUsername) external {\n        if (membersState.isMember(msg.sender)) revert ArisanErrors.MemberAlreadyExists();\n        if (membersState.memberAddresses.length >= membersState.capacityState.currentCapacity) {\n            revert ArisanErrors.GroupCapacityExceeded();\n        }\n        if (_isWaitingForJoinApproval(msg.sender)) revert ArisanErrors.AlreadyWaitingForJoinApproval();\n        if (bytes(telegramUsername).length == 0) revert ArisanErrors.InvalidParameters();\n        \n        // Store pending request\n        pendingJoinRequests[msg.sender] = telegramUsername;\n        \n        // Create new member proposal internally (using existing proposal system)\n        // This will require 50% approval from active voters\n        uint256 proposalIndex = proposalsState.createProposal(ProposalCategory.NewMember, msg.sender);\n        \n        newMemberProposalValues[proposalIndex] = NewMemberProposalValue({\n            memberAddress: msg.sender,\n            telegramUsername: telegramUsername\n        });\n        \n        emit JoinRequested(msg.sender, telegramUsername);\n        emit ProposalCreated(proposalIndex, ProposalCategory.NewMember, msg.sender);\n    }\n\n    /// @notice Join group directly without approval (if open join enabled)\n    /// @param telegramUsername Telegram username of new member\n    function joinGroupNoApproval(string calldata telegramUsername) external {\n        if (!openJoinEnabled) revert ArisanErrors.JoinMechanismNotOpen();\n        if (membersState.isMember(msg.sender)) revert ArisanErrors.MemberAlreadyExists();\n        if (membersState.memberAddresses.length >= membersState.capacityState.currentCapacity) {\n            revert ArisanErrors.GroupCapacityExceeded();\n        }\n        if (bytes(telegramUsername).length == 0) revert ArisanErrors.InvalidParameters();\n        \n        // Add directly as member\n        bool shouldBeActiveVoter = periodsState.getPeriodsCount() == 0;\n        membersState.addMember(msg.sender, telegramUsername, shouldBeActiveVoter);\n        \n        emit MemberJoined(msg.sender, telegramUsername);\n    }\n\n    /// @notice Receive ETH\n    receive() external payable {}\n}\n"},"src/interfaces/IGroup.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {\n    ProposalCategory,\n    ExternalMember,\n    ExternalPeriod,\n    ExternalRound,\n    ExternalProposal,\n    GroupData,\n    GroupSettings\n} from \"../types/ArisanTypes.sol\";\n\n/// @title IGroup\n/// @notice Interface for an Arisan group contract\n\ninterface IGroup {\n    // ========== Events ==========\n\n    /// @notice Emitted when a winner is drawn in a period\n    event WinnerDrawn(ExternalMember indexed winner, uint256 indexed periodIndex, uint256 indexed roundIndex);\n\n    /// @notice Emitted when a member joins the group\n    event MemberJoined(address indexed member, string telegramUsername);\n\n    /// @notice Emitted when a member leaves the group\n    event MemberLeft(address indexed member);\n\n    /// @notice Emitted when a period starts\n    event PeriodStarted(uint256 indexed periodIndex, uint256 timestamp);\n\n    /// @notice Emitted when a period ends\n    event PeriodEnded(uint256 indexed periodIndex, uint256 timestamp);\n\n    /// @notice Emitted when a proposal is created\n    event ProposalCreated(uint256 indexed proposalIndex, ProposalCategory indexed category, address indexed proposer);\n\n    /// @notice Emitted when a proposal is completed (approved or rejected)\n    event ProposalCompleted(uint256 indexed proposalIndex, bool indexed isApproved);\n\n    /// @notice Emitted when a transfer is executed\n    event TransferExecuted(address indexed recipient, uint256 amount);\n\n    // ========== View Functions ==========\n\n    /// @notice Get group title\n    function title() external view returns (string memory);\n\n    /// @notice Get telegram group URL\n    function telegramGroupUrl() external view returns (string memory);\n\n    /// @notice Get coordinator address\n    function coordinator() external view returns (address);\n\n    /// @notice Get coordinator commission percentage\n    function coordinatorCommissionPercentage() external view returns (uint256);\n\n    /// @notice Get contribution amount in wei\n    function contributionAmountInWei() external view returns (uint256);\n\n    /// @notice Get prize percentage\n    function prizePercentage() external view returns (uint256);\n\n    /// @notice Get Member by Address\n    function getMemberByAddress(address memberAddress) external view returns (ExternalMember memory);\n\n    /// @notice Check if someone is a member\n    function isMember(address person) external view returns (bool);\n\n    /// @notice Get Current Period Status\n    function getCurrentPeriod() external view returns (ExternalPeriod memory, bool onGoing);\n\n    /// @notice get all due winner in current periods\n    function getCurrentPeriodDueWinners() external view returns (address[] memory);\n\n    /// @notice get proposal by index (incomplete or complete)\n    function getProposalByIndex(uint256 index) external view returns (ExternalProposal memory);\n\n    /// @notice check if someone has voted on a proposal\n    function hasVotedOnProposal(uint256 proposalIndex, address voter) external view returns (bool);\n\n    /// @notice Get number of active voters\n    function getActiveVotersCount() external view returns (uint256);\n\n    /// @notice Get member address by index\n    function getMemberByIndex(uint256 index) external view returns (ExternalMember memory);\n\n    /// @notice Get total members count\n    function getMembersCount() external view returns (uint256);\n\n    /// @notice Get group details\n    function getGroupDetail() external view returns (GroupData memory);\n\n    /// @notice Get group settings\n    function getGroupSettings() external view returns (GroupSettings memory);\n\n    /// @notice Get period by index\n    function getPeriodByIndex(uint256 index) external view returns (ExternalPeriod memory);\n\n    /// @notice Get total periods count\n    function getPeriodsCount() external view returns (uint256);\n\n    /// @notice Get round details\n    function getRoundByIndexAndPeriodIndex(\n        uint256 roundIndex,\n        uint256 periodIndex\n    ) external view returns (ExternalRound memory);\n\n    /// @notice Get due winner by index and period index\n    function getDueWinnerByIndexAndPeriodIndex(\n        uint256 winnerIndex,\n        uint256 periodIndex\n    ) external view returns (ExternalMember memory);\n\n    /// @notice Get incomplete proposals count\n    function getIncompleteProposalsCount() external view returns (uint256);\n\n    /// @notice Get incomplete proposal by index\n    function getIncompleteProposalByIndex(uint256 index) external view returns (ExternalProposal memory);\n\n    /// @notice Get approver by index and proposal index\n    function getApproverByIndexAndProposalIndex(\n        uint256 approverIndex,\n        uint256 proposalIndex\n    ) external view returns (ExternalMember memory);\n\n    // ========== Member Management ==========\n\n    /// @notice Propose a new member to join the group\n    /// @param memberAddress Address of the new member\n    /// @param telegramUsername Telegram username of the new member\n    function proposeNewMember(address memberAddress, string calldata telegramUsername) external;\n\n    /// @notice Approve a new member proposal\n    /// @param proposalIndex Index of the proposal\n    function approveNewMemberProposal(uint256 proposalIndex) external;\n\n    /// @notice Reject a new member proposal\n    /// @param proposalIndex Index of the proposal\n    function rejectNewMemberProposal(uint256 proposalIndex) external;\n\n    /// @notice Leave the group (not applicable for coordinator)\n    function leave() external;\n\n    // ========== Period Management ==========\n\n    /// @notice Start a new period (coordinator only)\n    function startPeriod() external payable;\n\n    /// @notice Contribute to the current period\n    /// @param periodIndex Index of the period\n    function contribute(uint256 periodIndex) external payable;\n\n    /// @notice Draw a winner for the current round (coordinator only)\n    /// @param periodIndex Index of the period\n    function drawWinner(uint256 periodIndex) external;\n\n    // ========== Governance: Title Proposals ==========\n\n    /// @notice Propose a new group title\n    /// @param newValue The new title\n    function proposeNewTitle(string calldata newValue) external;\n\n    /// @notice Approve a title change proposal\n    /// @param proposalIndex Index of the proposal\n    function approveNewTitleProposal(uint256 proposalIndex) external;\n\n    /// @notice Reject a title change proposal\n    /// @param proposalIndex Index of the proposal\n    function rejectStringProposal(uint256 proposalIndex) external;\n\n    // ========== Governance: Telegram URL Proposals ==========\n\n    /// @notice Propose a new telegram group URL\n    /// @param newValue The new URL\n    function proposeNewTelegramGroupUrl(string calldata newValue) external;\n\n    /// @notice Approve a telegram URL change proposal\n    /// @param proposalIndex Index of the proposal\n    function approveNewTelegramGroupUrlProposal(uint256 proposalIndex) external;\n\n    // ========== Governance: Contribution Amount Proposals ==========\n\n    /// @notice Propose a new contribution amount\n    /// @param newContributionAmountInWei The new contribution amount\n    function proposeNewContributionAmountInWei(uint256 newContributionAmountInWei) external;\n\n    /// @notice Approve a contribution amount change proposal\n    /// @param proposalIndex Index of the proposal\n    function approveContributionAmountProposal(uint256 proposalIndex) external;\n\n    /// @notice Reject a contribution amount proposal\n    /// @param proposalIndex Index of the proposal\n    function rejectUintProposal(uint256 proposalIndex) external;\n\n    // ========== Governance: Prize Percentage Proposals ==========\n\n    /// @notice Propose a new prize percentage\n    /// @param newPrizePercentage The new prize percentage\n    function proposeNewPrizePercentage(uint256 newPrizePercentage) external;\n\n    /// @notice Approve a prize percentage change proposal\n    /// @param proposalIndex Index of the proposal\n    function approvePrizePercentageProposal(uint256 proposalIndex) external;\n\n    // ========== Governance: Coordinator Commission Proposals ==========\n\n    /// @notice Propose a new coordinator commission percentage\n    /// @param newCoordinatorCommissionPercentage The new commission percentage\n    function proposeNewCoordinatorCommissionPercentage(\n        uint256 newCoordinatorCommissionPercentage\n    ) external;\n\n    /// @notice Approve a coordinator commission change proposal\n    /// @param proposalIndex Index of the proposal\n    function approveNewCoordinatorCommissionPercentageProposal(uint256 proposalIndex) external;\n\n    // ========== Governance: Coordinator Proposals ==========\n\n    /// @notice Propose a new coordinator\n    /// @param newCoordinator Address of the new coordinator\n    function proposeNewCoordinator(address newCoordinator) external;\n\n    /// @notice Approve a new coordinator proposal\n    /// @param proposalIndex Index of the proposal\n    function approveNewCoordinatorProposal(uint256 proposalIndex) external;\n\n    /// @notice Reject a new coordinator proposal\n    /// @param proposalIndex Index of the proposal\n    function rejectNewCoordinatorProposal(uint256 proposalIndex) external;\n\n    // ========== Governance: Transfer Proposals ==========\n\n    /// @notice Propose a transfer of funds\n    /// @param recipient Address to receive the funds\n    /// @param transferAmount Amount to transfer\n    function proposeTransfer(address recipient, uint256 transferAmount) external;\n\n    /// @notice Approve a transfer proposal\n    /// @param proposalIndex Index of the proposal\n    function approveTransferProposal(uint256 proposalIndex) external;\n\n    /// @notice Reject a transfer proposal\n    /// @param proposalIndex Index of the proposal\n    function rejectTransferProposal(uint256 proposalIndex) external;\n\n    // ========== Capacity Upgrade & Signatures ==========\n    /// @notice Emitted when group capacity is upgraded\n    event CapacityUpgraded(\n        uint256 indexed previousCapacity,\n        uint256 indexed newCapacity,\n        uint256 indexed upgradeCost\n    );\n\n    function upgradeCapacity() external payable;\n    function getMaxCapacity() external view returns (uint256);\n    function getAvailableCapacity() external view returns (uint256);\n    function getCapacityUpgradeCount() external view returns (uint256);\n    function getNextCapacityTier() external view returns (uint256);\n\n    // ========== New Join Functions ==========\n\n    /// @notice Request to join with member approval (requires 50% vote)\n    function joinGroup(string calldata telegramUsername) external;\n\n    /// @notice Join directly without approval (if enabled by coordinator)\n    function joinGroupNoApproval(string calldata telegramUsername) external;\n\n    /// @notice Toggle open join setting\n    function toggleOpenJoin(bool enabled) external;\n\n    /// @notice Check if open join is enabled\n    function isOpenJoinEnabled() external view returns (bool);\n\n    // ========== New Events ==========\n\n    /// @notice Emitted when a member requests to join (approval-based)\n    event JoinRequested(address indexed applicant, string telegramUsername);\n\n    /// @notice Emitted when join request is approved\n    event JoinApproved(address indexed applicant);\n\n    /// @notice Emitted when join request is rejected\n    event JoinRejected(address indexed applicant);\n\n    /// @notice Emitted when open join setting changes\n    event OpenJoinToggled(bool enabled);\n\n    // ========== Kicking Related ==========\n\n    /// @notice propose kicking a member\n    function proposeKickMember(address memberToKick) external;\n\n    /// @notice Approve kicking a member\n    function approveKickMemberProposal(uint256 proposalIndex) external;\n\n    /// @notice Emitter when a member is kicked\n    event MemberKicked(address indexed kickedMember);\n}\n"},"src/types/ArisanTypes.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @title ArisanTypes\n/// @notice Shared types, enums, and structs for Arisan protocol\n\n// ========== Enums ==========\n\n/// @notice Status of a user's membership in a group\nenum JoinStatus {\n    Unknown,\n    NotJoined,\n    WaitingApproval,\n    Joined\n}\n\n/// @notice Status of a member's vote on a proposal\nenum ApprovalStatus {\n    Unset,\n    Approved,\n    Rejected\n}\n\n/// @notice Category of a governance proposal\nenum ProposalCategory {\n    Title,\n    TelegramGroupUrl,\n    ContributionAmount,\n    PrizePercentage,\n    CoordinatorCommissionPercentage,\n    Coordinator,\n    NewMember,\n    Transfer,\n    KickMember\n}\n\n// ========== Data Structs ==========\n\n/// @notice Internal representation of a group member\nstruct Member {\n    string telegramUsername;\n    bool isActiveVoter;\n    uint256 latestPeriodParticipation;\n}\n\n/// @notice External representation of a member (for return values)\nstruct ExternalMember {\n    address walletAddress;\n    string telegramUsername;\n    bool isActiveVoter;\n    uint256 latestPeriodParticipation;\n}\n\n/// @notice A single round within a period\nstruct Round {\n    uint256 drawnAt;\n    address winner;\n    uint256 contributorCount;\n}\n\n/// @notice External representation of a round\nstruct ExternalRound {\n    uint256 drawnAt;\n    ExternalMember winner;\n    uint256 contributorCount;\n}\n\n/// @notice Internal representation of an Arisan period\nstruct Period {\n    uint256 startedAt;\n    uint256 endedAt;\n    uint256 remainingPeriodBalanceInWei;\n    uint256 contributionAmountInWei;\n    uint256 coordinatorCommissionPercentage;\n    uint256 prizePercentage;\n    address[] participants;\n    Round[] rounds;\n    address[] dueWinners;\n}\n\n/// @notice External representation of a period (for return values)\nstruct ExternalPeriod {\n    uint256 startedAt;\n    uint256 endedAt;\n    uint256 remainingPeriodBalanceInWei;\n    uint256 contributionAmountInWei;\n    uint256 coordinatorCommissionPercentage;\n    uint256 prizePercentage;\n    uint256 roundsCount;\n    uint256 dueWinnersCount;\n}\n\n/// @notice Internal representation of a governance proposal\nstruct Proposal {\n    ProposalCategory category;\n    uint256 proposedAt;\n    address proposer;\n    uint256 completedAt;\n    bool isApproved;\n    address[] approvers;\n}\n\n/// @notice External representation of a proposal (for return values)\nstruct ExternalProposal {\n    uint256 index;\n    ProposalCategory category;\n    uint256 proposedAt;\n    ExternalMember proposer;\n    uint256 completedAt;\n    bool isApproved;\n    uint256 approversCount;\n    string stringProposalValue;\n    uint256 uintProposalValue;\n    ExternalMember coordinatorProposalValue;\n    NewMemberProposalValue newMemberProposalValue;\n    TransferProposalValue transferProposalValue;\n}\n\n/// @notice Configuration details for a new member proposal\nstruct NewMemberProposalValue {\n    address memberAddress;\n    string telegramUsername;\n}\n\n/// @notice Configuration details for a transfer proposal\nstruct TransferProposalValue {\n    address payable recipient;\n    uint256 transferAmount;\n}\n\n/// @notice Group information for external queries\nstruct GroupData {\n    address groupAddress;\n    string title;\n    string telegramGroupUrl;\n    uint256 membersCount;\n    address[] memberAddresses;\n    JoinStatus joinStatus;\n}\n\n/// @notice Group settings for external queries\nstruct GroupSettings {\n    string title;\n    string telegramGroupUrl;\n    ExternalMember coordinator;\n    uint256 coordinatorCommissionPercentage;\n    uint256 contributionAmountInWei;\n    uint256 prizePercentage;\n    uint256 maxCapacity;\n    uint256 capacityUpgradeCount;\n    bool openJoinEnabled;\n}\n"},"src/errors/ArisanErrors.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @title ArisanErrors\n/// @notice Custom errors for Arisan protocol\nlibrary ArisanErrors {\n    // ========== Access Control Errors ==========\n    \n    /// @notice Caller is not the coordinator\n    error NotCoordinator();\n    \n    /// @notice Caller is not a member of the group\n    error NotMember();\n    \n    /// @notice Caller is not an active voter\n    error NotActiveVoter();\n    \n    // ========== Validation Errors ==========\n    \n    /// @notice Invalid input parameters provided\n    error InvalidParameters();\n    \n    /// @notice Title is empty\n    error EmptyTitle();\n    \n    /// @notice Telegram group URL is empty\n    error EmptyTelegramUrl();\n    \n    /// @notice Coordinator telegram username is empty\n    error EmptyCoordinatorUsername();\n    \n    /// @notice Contribution amount must be greater than zero\n    error InvalidContributionAmount();\n    \n    /// @notice Commission percentage is too high\n    // error CommissionPercentageTooHigh();\n    // replaced below\n    \n    /// @notice Prize percentage is too high\n    error PrizePercentageTooHigh();\n    \n    /// @notice Sum of commission and prize exceeds 100%\n    error PercentagesSumExceeds100();\n    \n    /// @notice Coordinator cannot leave the group\n    error CoordinatorCannotLeave();\n    \n    // ========== Period Errors ==========\n    \n    /// @notice Tried to start period when last period hasn't ended\n    error LastPeriodNotEnded();\n    \n    /// @notice Tried to access period that doesn't exist\n    error PeriodDoesNotExist();\n    \n    /// @notice Period is no longer ongoing\n    error PeriodEnded();\n    \n    /// @notice Participant already contributed for this round\n    error AlreadyContributedThisRound();\n    \n    /// @notice Contribution amount is incorrect\n    error IncorrectContributionAmount();\n    \n    /// @notice Cannot draw winner yet, not all participants have contributed\n    error IncompleteRound();\n    \n    /// @notice All participants have already won this period\n    error NoDueWinnersRemaining();\n    \n    /// @notice No period is currently ongoing\n    error NoPeriodOngoing();\n    \n    /// @notice Participant is still participating in ongoing period\n    error StillParticipatingInPeriod();\n    \n    /// @notice Participant hasn't participated in required round\n    error DidNotParticipateInPreviousRound();\n    \n    // ========== Proposal Errors ==========\n    \n    /// @notice Proposal does not exist\n    error ProposalDoesNotExist();\n    \n    /// @notice Proposal has already been completed\n    error ProposalAlreadyCompleted();\n    \n    /// @notice Caller has already voted on this proposal\n    error AlreadyVotedOnProposal();\n    \n    /// @notice Proposal category mismatch\n    error InvalidProposalCategory();\n    \n    /// @notice Cannot have incomplete proposals when ending period\n    error IncompleteProposalsRemaining();\n    \n    /// @notice Cannot join while waiting for previous join approval\n    error AlreadyWaitingForJoinApproval();\n    \n    /// @notice Member already exists\n    error MemberAlreadyExists();\n    \n    /// @notice Cannot leave without ending period participation\n    error CannotLeaveWhileParticipating();\n    \n    // ========== Finance Errors ==========\n    \n    /// @notice Insufficient balance for transfer\n    error InsufficientBalance();\n    \n    /// @notice Transfer failed\n    error TransferFailed();\n    \n    /// @notice Recipient address is invalid\n    error InvalidRecipient();\n    \n    /// @notice Amount is zero\n    error AmountIsZero();\n    \n    // ========== Member Errors ==========\n    \n    /// @notice Member does not exist\n    error MemberDoesNotExist();\n    \n    /// @notice Invalid member index\n    error InvalidMemberIndex();\n\n    // ========== Capacity Errors ==========\n\n    /// @notice Group is at maximum capacity\n    error GroupCapacityExceeded();\n\n    /// @notice Insufficient funds for capacity upgrade\n    error InsufficientCapacityUpgradeFunds();\n\n    /// @notice Exact payment amount required for capacity upgrade\n    error IncorrectCapacityUpgradePayment();\n\n    /// @notice Cannot upgrade at current member count\n    error CannotUpgradeAtCurrentMemberCount();\n\n    // ========== Platform Fee & Commission Errors ==========\n\n    /// @notice Coordinator commission is below minimum (5%)\n    error CommissionTooLow();\n\n    /// @notice Coordinator commission exceeds maximum (50%)\n    error CommissionPercentageTooHigh();\n\n    // ========== Join Mechanism Errors ==========\n\n    /// @notice Member cannot propose themselves\n    error CannotProposeSelf();\n\n    /// @notice Join mechanism is not open (no approval-less join)\n    error JoinMechanismNotOpen();\n    \n    // ========== Generic Errors ==========\n    \n    /// @notice Operation failed\n    error OperationFailed();\n\n    /// @notice kick self\n    error CannotKickSelf();\n\n    /// @notice due winner not found\n    error DueWinnerNotFound();\n}\n"},"src/libraries/ArisanMembers.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {Member, ExternalMember} from \"../types/ArisanTypes.sol\";\nimport {ArisanErrors} from \"../errors/ArisanErrors.sol\";\nimport {ArisanCapacity} from \"./ArisanCapacity.sol\";\n\n/// @title ArisanMembers\n/// @notice Library for managing group members and their voting rights\n\nlibrary ArisanMembers {\n    // ========== Types ==========\n\n    /// @notice Member management state\n    struct MembersState {\n        address[] memberAddresses;\n        mapping(address => uint256) memberIndices; // index + 1 (0 = not a member)\n        mapping(address => Member) members;\n        uint256 activeVotersCount;\n        ArisanCapacity.CapacityState capacityState;\n    }\n\n    // ========== Constants ==========\n\n    /// @notice Offset used in memberIndices mapping (0 means not a member)\n    uint256 private constant INDEX_OFFSET = 1;\n\n    // ========== View Functions ==========\n\n    /// @notice Check if an address is a member of the group\n    /// @param state The members state\n    /// @param account Address to check\n    /// @return True if the address is a member\n    function isMember(MembersState storage state, address account) internal view returns (bool) {\n        return state.memberIndices[account] > 0;\n    }\n\n    /// @notice Check if a member is an active voter\n    /// @param state The members state\n    /// @param account Member address\n    /// @return True if the member is an active voter\n    function isActiveVoter(MembersState storage state, address account) internal view returns (bool) {\n        if (!isMember(state, account)) return false;\n        return state.members[account].isActiveVoter;\n    }\n\n    /// @notice Get total number of members\n    /// @param state The members state\n    /// @return Number of members\n    function getMembersCount(MembersState storage state) internal view returns (uint256) {\n        return state.memberAddresses.length;\n    }\n\n    /// @notice Get active voters count\n    /// @param state The members state\n    /// @return Number of active voters\n    function getActiveVotersCount(MembersState storage state) internal view returns (uint256) {\n        return state.activeVotersCount;\n    }\n\n    /// @notice Get member by address\n    /// @param state The members state\n    /// @param account Member address\n    /// @return The member details\n    function getMemberByAddress(MembersState storage state, address account)\n        internal\n        view\n        returns (Member storage)\n    {\n        if (!isMember(state, account)) revert ArisanErrors.NotMember();\n        return state.members[account];\n    }\n\n    /// @notice Get member by index in the members array\n    /// @param state The members state\n    /// @param index Index in members array\n    /// @return memberAddress Address of the member\n    /// @return member The member details\n    function getMemberByIndex(MembersState storage state, uint256 index)\n        internal\n        view\n        returns (address memberAddress, Member storage member)\n    {\n        if (index >= state.memberAddresses.length) revert ArisanErrors.InvalidMemberIndex();\n        memberAddress = state.memberAddresses[index];\n        member = state.members[memberAddress];\n    }\n\n    /// @notice Get all member addresses\n    /// @param state The members state\n    /// @return Array of member addresses\n    function getAllMemberAddresses(MembersState storage state)\n        internal\n        view\n        returns (address[] memory)\n    {\n        return state.memberAddresses;\n    }\n\n    /// @notice Get current group capacity limit\n    function getMaxCapacity(MembersState storage state) internal view returns (uint256) {\n        return state.capacityState.currentCapacity;\n    }\n\n    /// @notice Get available member slots\n    function getAvailableCapacity(MembersState storage state) internal view returns (uint256) {\n        return ArisanCapacity.getAvailableCapacity(state.capacityState, state.memberAddresses.length);\n    }\n\n    /// @notice Convert member to external representation\n    /// @param member The member struct\n    /// @param walletAddress The wallet address\n    /// @return External member representation\n    function toExternal(address walletAddress, Member storage member)\n        internal\n        view\n        returns (ExternalMember memory)\n    {\n        return ExternalMember({\n            walletAddress: walletAddress,\n            telegramUsername: member.telegramUsername,\n            isActiveVoter: member.isActiveVoter,\n            latestPeriodParticipation: member.latestPeriodParticipation\n        });\n    }\n\n    // ========== Modification Functions ==========\n\n    /// @notice Add a new member to the group\n    /// @param state The members state\n    /// @param memberAddress Address of the new member\n    /// @param telegramUsername Telegram username\n    /// @param shouldBeActiveVoter Whether the member should be an active voter\n    function addMember(\n        MembersState storage state,\n        address memberAddress,\n        string memory telegramUsername,\n        bool shouldBeActiveVoter\n    ) internal {\n        if (isMember(state, memberAddress)) revert ArisanErrors.MemberAlreadyExists();\n        if (bytes(telegramUsername).length == 0) revert ArisanErrors.EmptyCoordinatorUsername();\n\n        if (state.memberAddresses.length >= state.capacityState.currentCapacity) {\n            revert ArisanErrors.GroupCapacityExceeded();\n        }\n\n        state.memberAddresses.push(memberAddress);\n        state.memberIndices[memberAddress] = state.memberAddresses.length;\n\n        state.members[memberAddress] = Member({\n            telegramUsername: telegramUsername,\n            isActiveVoter: shouldBeActiveVoter,\n            latestPeriodParticipation: 0\n        });\n\n        if (shouldBeActiveVoter) {\n            state.activeVotersCount++;\n        }\n    }\n\n    /// @notice Remove a member from the group (swap and pop strategy)\n    /// @param state The members state\n    /// @param memberAddress Address of the member to remove\n    function removeMember(MembersState storage state, address memberAddress) internal {\n        if (!isMember(state, memberAddress)) revert ArisanErrors.NotMember();\n\n        // Get the index (subtract 1 because we store index + 1)\n        uint256 indexToRemove = state.memberIndices[memberAddress] - INDEX_OFFSET;\n        uint256 lastIndex = state.memberAddresses.length - 1;\n\n        // If not the last member, swap with last member\n        if (indexToRemove != lastIndex) {\n            address lastAddress = state.memberAddresses[lastIndex];\n            state.memberAddresses[indexToRemove] = lastAddress;\n            state.memberIndices[lastAddress] = indexToRemove + INDEX_OFFSET;\n        }\n\n        // Remove last member\n        state.memberAddresses.pop();\n\n        // Deactivate voting if necessary\n        if (state.members[memberAddress].isActiveVoter) {\n            state.activeVotersCount--;\n        }\n\n        // Clean up mappings\n        delete state.memberIndices[memberAddress];\n        delete state.members[memberAddress];\n    }\n\n    /// @notice Set a member as active voter\n    /// @param state The members state\n    /// @param memberAddress Address of the member\n    function setActiveVoter(MembersState storage state, address memberAddress) internal {\n        if (!isMember(state, memberAddress)) revert ArisanErrors.NotMember();\n\n        if (!state.members[memberAddress].isActiveVoter) {\n            state.members[memberAddress].isActiveVoter = true;\n            state.activeVotersCount++;\n        }\n    }\n\n    /// @notice Set a member as inactive voter\n    /// @param state The members state\n    /// @param memberAddress Address of the member\n    function setInactiveVoter(MembersState storage state, address memberAddress) internal {\n        if (!isMember(state, memberAddress)) revert ArisanErrors.NotMember();\n\n        if (state.members[memberAddress].isActiveVoter) {\n            state.members[memberAddress].isActiveVoter = false;\n            state.activeVotersCount--;\n        }\n    }\n\n    /// @notice Update member's latest period participation\n    /// @param state The members state\n    /// @param memberAddress Address of the member\n    /// @param periodIndex Index of the latest period they participated in\n    function updateLatestPeriodParticipation(\n        MembersState storage state,\n        address memberAddress,\n        uint256 periodIndex\n    ) internal {\n        if (!isMember(state, memberAddress)) revert ArisanErrors.NotMember();\n        state.members[memberAddress].latestPeriodParticipation = periodIndex;\n    }\n\n    /// @notice Get Member Participation Status in period\n    /// @param state The members state\n    /// @param memberAddress Address of the member\n    /// @param periodIndex Index of the latest period they participated in\n    function getCurrentPeriodParticipationStatus(\n        MembersState storage state,\n        address memberAddress,\n        uint256 periodIndex\n    ) internal view returns (bool) {\n        if (!isMember(state, memberAddress)) revert ArisanErrors.NotMember();\n        return state.members[memberAddress].latestPeriodParticipation == periodIndex;\n    }\n\n    /// @notice Update member's telegram username\n    /// @param state The members state\n    /// @param memberAddress Address of the member\n    /// @param newUsername New telegram username\n    function updateTelegramUsername(\n        MembersState storage state,\n        address memberAddress,\n        string memory newUsername\n    ) internal {\n        if (!isMember(state, memberAddress)) revert ArisanErrors.NotMember();\n        if (bytes(newUsername).length == 0) revert ArisanErrors.EmptyCoordinatorUsername();\n        state.members[memberAddress].telegramUsername = newUsername;\n    }\n}\n"},"src/libraries/ArisanPeriods.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {Period, Round, ExternalPeriod, ExternalRound} from \"../types/ArisanTypes.sol\";\nimport {ArisanErrors} from \"../errors/ArisanErrors.sol\";\nimport {ArisanMembers} from \"./ArisanMembers.sol\";\n\n/// @title ArisanPeriods\n/// @notice Library for managing Arisan periods and rounds\n\nlibrary ArisanPeriods {\n    // ========== Types ==========\n\n    /// @notice Period management state\n    struct PeriodsState {\n        Period[] periods;\n        mapping(uint256 => mapping(address => uint256)) periodToParticipantContributionCount;\n    }\n\n    // ========== View Functions ==========\n\n    /// @notice Get total number of periods\n    /// @param state The periods state\n    /// @return Number of periods\n    function getPeriodsCount(PeriodsState storage state) internal view returns (uint256) {\n        return state.periods.length;\n    }\n\n    /// @notice Check if a period exists\n    /// @param state The periods state\n    /// @param periodIndex Index of the period\n    /// @return True if the period exists\n    function periodExists(PeriodsState storage state, uint256 periodIndex)\n        internal\n        view\n        returns (bool)\n    {\n        return periodIndex < state.periods.length;\n    }\n\n    /// @notice Check if a period is ongoing\n    /// @param state The periods state\n    /// @param periodIndex Index of the period\n    /// @return True if the period is ongoing (hasn't ended)\n    function isPeriodOngoing(PeriodsState storage state, uint256 periodIndex)\n        internal\n        view\n        returns (bool)\n    {\n        if (!periodExists(state, periodIndex)) return false;\n        return state.periods[periodIndex].endedAt == 0;\n    }\n\n    /// @notice Get the last period\n    /// @param state The periods state\n    /// @return Period storage reference\n    function getLastPeriod(PeriodsState storage state) internal view returns (Period storage) {\n        if (state.periods.length == 0) revert ArisanErrors.NoPeriodOngoing();\n        return state.periods[state.periods.length - 1];\n    }\n\n    /// @notice Get the last round of a period\n    /// @param state The periods state\n    /// @param periodIndex Index of the period\n    /// @return Round storage reference\n    function getLastRound(PeriodsState storage state, uint256 periodIndex)\n        internal\n        view\n        returns (Round storage)\n    {\n        if (!periodExists(state, periodIndex)) revert ArisanErrors.PeriodDoesNotExist();\n        Period storage period = state.periods[periodIndex];\n        if (period.rounds.length == 0) revert ArisanErrors.PeriodDoesNotExist();\n        return period.rounds[period.rounds.length - 1];\n    }\n\n    /// @notice Get period by index\n    /// @param state The periods state\n    /// @param periodIndex Index of the period\n    /// @return External period representation\n    function getPeriodByIndex(PeriodsState storage state, uint256 periodIndex)\n        internal\n        view\n        returns (ExternalPeriod memory)\n    {\n        if (!periodExists(state, periodIndex)) revert ArisanErrors.PeriodDoesNotExist();\n\n        Period storage period = state.periods[periodIndex];\n        return ExternalPeriod({\n            startedAt: period.startedAt,\n            endedAt: period.endedAt,\n            remainingPeriodBalanceInWei: period.remainingPeriodBalanceInWei,\n            contributionAmountInWei: period.contributionAmountInWei,\n            coordinatorCommissionPercentage: period.coordinatorCommissionPercentage,\n            prizePercentage: period.prizePercentage,\n            roundsCount: period.rounds.length,\n            dueWinnersCount: period.dueWinners.length\n        });\n    }\n\n    /// @notice Get round by index\n    /// @param state The periods state\n    /// @param periodIndex Index of the period\n    /// @param roundIndex Index of the round\n    /// @return External round representation\n    function getRoundByIndex(\n        PeriodsState storage state,\n        uint256 periodIndex,\n        uint256 roundIndex,\n        ArisanMembers.MembersState storage membersState\n    ) internal view returns (ExternalRound memory) {\n        if (!periodExists(state, periodIndex)) revert ArisanErrors.PeriodDoesNotExist();\n        if (roundIndex >= state.periods[periodIndex].rounds.length)\n            revert ArisanErrors.PeriodDoesNotExist();\n\n        Round storage round = state.periods[periodIndex].rounds[roundIndex];\n        return ExternalRound({\n            drawnAt: round.drawnAt,\n            winner: ArisanMembers.toExternal(round.winner, membersState.members[round.winner]),\n            contributorCount: round.contributorCount\n        });\n    }\n\n    /// @notice Get participant count for a period (snapshot at period start)\n    /// @param state The periods state\n    /// @param periodIndex Index of the period\n    /// @return Number of expected participants\n    function getParticipantCount(PeriodsState storage state, uint256 periodIndex)\n        internal\n        view\n        returns (uint256)\n    {\n        if (!periodExists(state, periodIndex)) revert ArisanErrors.PeriodDoesNotExist();\n        return state.periods[periodIndex].participants.length;\n    }\n\n    /// @notice Get participation count for a member in a period\n    /// @param state The periods state\n    /// @param periodIndex Index of the period\n    /// @param participant Address of the participant\n    /// @return Number of times they contributed\n    function getParticipationCount(\n        PeriodsState storage state,\n        uint256 periodIndex,\n        address participant\n    ) internal view returns (uint256) {\n        return state.periodToParticipantContributionCount[periodIndex][participant];\n    }\n\n    /// @notice Check if participant has participated in a period\n    /// @param state The periods state\n    /// @param periodIndex Index of the period\n    /// @param participant Address of the participant\n    /// @return True if they have participated\n    function hasParticipated(\n        PeriodsState storage state,\n        uint256 periodIndex,\n        address participant\n    ) internal view returns (bool) {\n        return state.periodToParticipantContributionCount[periodIndex][participant] > 0;\n    }\n\n    /// @notice Get all due winners for a period\n    /// @param state The periods state\n    /// @param periodIndex Index of the period\n    /// @return Array of due winner addresses\n    function getDueWinners(PeriodsState storage state, uint256 periodIndex)\n        internal\n        view\n        returns (address[] memory)\n    {\n        if (!periodExists(state, periodIndex)) revert ArisanErrors.PeriodDoesNotExist();\n        return state.periods[periodIndex].dueWinners;\n    }\n\n    /// @notice Get due winner by index\n    /// @param state The periods state\n    /// @param periodIndex Index of the period\n    /// @param winnerIndex Index in dueWinners array\n    /// @return Address of the due winner\n    function getDueWinnerByIndex(\n        PeriodsState storage state,\n        uint256 periodIndex,\n        uint256 winnerIndex\n    ) internal view returns (address) {\n        if (!periodExists(state, periodIndex)) revert ArisanErrors.PeriodDoesNotExist();\n        if (winnerIndex >= state.periods[periodIndex].dueWinners.length)\n            revert ArisanErrors.NoDueWinnersRemaining();\n        return state.periods[periodIndex].dueWinners[winnerIndex];\n    }\n\n    /// @notice return the index of due winner based on address\n    /// @param state The periods state\n    /// @param periodIndex Index of the period\n    /// @param memberAddress Address of the member to be checked\n    /// @return Index of the due winner for specified address\n    function getDueWinnerIndexByAddress(\n        PeriodsState storage state,\n        uint256 periodIndex,\n        address memberAddress\n    ) internal view returns (uint256) {\n        if (!periodExists(state, periodIndex)) revert ArisanErrors.PeriodDoesNotExist();\n        uint256 dueWinnersCount = state.periods[periodIndex].dueWinners.length;\n\n        for (uint i = 0; i < dueWinnersCount; i++) {\n            if (state.periods[periodIndex].dueWinners[i] == memberAddress) {\n                return i;\n            }\n        }\n\n        revert ArisanErrors.DueWinnerNotFound();\n    }\n\n    /// @notice Count total contributors in a round\n    /// @param state The periods state\n    /// @param periodIndex Index of the period\n    /// @param roundIndex Index of the round\n    /// @return Number of contributors\n    function getContributorCount(\n        PeriodsState storage state,\n        uint256 periodIndex,\n        uint256 roundIndex\n    ) internal view returns (uint256) {\n        if (!periodExists(state, periodIndex)) revert ArisanErrors.PeriodDoesNotExist();\n        if (roundIndex >= state.periods[periodIndex].rounds.length)\n            revert ArisanErrors.PeriodDoesNotExist();\n        return state.periods[periodIndex].rounds[roundIndex].contributorCount;\n    }\n\n    // ========== Modification Functions ==========\n\n    /// @notice Create a new period\n    /// @param state The periods state\n    /// @param coordinatorCommissionPercentage Commission percentage\n    /// @param contributionAmountInWei Contribution amount\n    /// @param prizePercentage Prize percentage\n    /// @return periodIndex Index of the new period\n    function createPeriod(\n        PeriodsState storage state,\n        uint256 coordinatorCommissionPercentage,\n        uint256 contributionAmountInWei,\n        uint256 prizePercentage,\n        address[] memory periodParticipants\n    ) internal returns (uint256) {\n        Period storage newPeriod = state.periods.push();\n        newPeriod.startedAt = block.timestamp;\n        newPeriod.contributionAmountInWei = contributionAmountInWei;\n        newPeriod.coordinatorCommissionPercentage = coordinatorCommissionPercentage;\n        newPeriod.prizePercentage = prizePercentage;\n        newPeriod.participants = periodParticipants;\n        newPeriod.dueWinners = periodParticipants;\n        newPeriod.rounds.push(); // Create first round\n\n        return state.periods.length - 1;\n    }\n\n    /// @notice End a period\n    /// @param state The periods state\n    /// @param periodIndex Index of the period\n    function endPeriod(PeriodsState storage state, uint256 periodIndex) internal {\n        if (!periodExists(state, periodIndex)) revert ArisanErrors.PeriodDoesNotExist();\n        if (!isPeriodOngoing(state, periodIndex)) revert ArisanErrors.PeriodEnded();\n        state.periods[periodIndex].endedAt = block.timestamp;\n    }\n\n    /// @notice Record a contribution from a participant\n    /// @param state The periods state\n    /// @param periodIndex Index of the period\n    /// @param participant Address of the participant\n    /// @param amount Amount contributed\n    function recordContribution(\n        PeriodsState storage state,\n        uint256 periodIndex,\n        address participant,\n        uint256 amount\n    ) internal {\n        if (!periodExists(state, periodIndex)) revert ArisanErrors.PeriodDoesNotExist();\n\n        Period storage period = state.periods[periodIndex];\n        \n        // Update participation count to match current round number\n        state.periodToParticipantContributionCount[periodIndex][participant] = period.rounds.length;\n\n        // Update balance and round contributor count\n        period.remainingPeriodBalanceInWei += amount;\n        period.rounds[period.rounds.length - 1].contributorCount++;\n    }\n\n    /// @notice Register a winner for a round\n    /// @param state The periods state\n    /// @param periodIndex Index of the period\n    /// @param roundIndex Index of the round\n    /// @param winner Address of the winner\n    /// @param timestamp Timestamp when drawn\n    function registerWinner(\n        PeriodsState storage state,\n        uint256 periodIndex,\n        uint256 roundIndex,\n        address winner,\n        uint256 timestamp\n    ) internal {\n        if (!periodExists(state, periodIndex)) revert ArisanErrors.PeriodDoesNotExist();\n        if (roundIndex >= state.periods[periodIndex].rounds.length)\n            revert ArisanErrors.PeriodDoesNotExist();\n\n        Round storage round = state.periods[periodIndex].rounds[roundIndex];\n        round.drawnAt = timestamp;\n        round.winner = winner;\n    }\n\n    /// @notice Remove a due winner from the period\n    /// @param state The periods state\n    /// @param periodIndex Index of the period\n    /// @param winnerIndex Index in the dueWinners array\n    function removeDueWinner(\n        PeriodsState storage state,\n        uint256 periodIndex,\n        uint256 winnerIndex\n    ) internal {\n        if (!periodExists(state, periodIndex)) revert ArisanErrors.PeriodDoesNotExist();\n\n        Period storage period = state.periods[periodIndex];\n        if (winnerIndex >= period.dueWinners.length) revert ArisanErrors.NoDueWinnersRemaining();\n\n        // Swap with last and pop\n        address lastWinner = period.dueWinners[period.dueWinners.length - 1];\n        period.dueWinners[winnerIndex] = lastWinner;\n        period.dueWinners.pop();\n    }\n\n    /// @notice Create a new round in the period\n    /// @param state The periods state\n    /// @param periodIndex Index of the period\n    function createNewRound(PeriodsState storage state, uint256 periodIndex) internal {\n        if (!periodExists(state, periodIndex)) revert ArisanErrors.PeriodDoesNotExist();\n        state.periods[periodIndex].rounds.push();\n    }\n\n    /// @notice Update period balance after payouts\n    /// @param state The periods state\n    /// @param periodIndex Index of the period\n    /// @param amount Amount to deduct\n    function deductFromBalance(\n        PeriodsState storage state,\n        uint256 periodIndex,\n        uint256 amount\n    ) internal {\n        if (!periodExists(state, periodIndex)) revert ArisanErrors.PeriodDoesNotExist();\n        state.periods[periodIndex].remainingPeriodBalanceInWei -= amount;\n    }\n\n    /// @notice Period to ExternalPeriod for external data read\n    /// @param period the period data\n    function toExternal(Period storage period) internal view returns (ExternalPeriod memory) {\n        return ExternalPeriod({\n            startedAt: period.startedAt,\n            endedAt: period.endedAt,\n            remainingPeriodBalanceInWei: period.remainingPeriodBalanceInWei,\n            contributionAmountInWei: period.contributionAmountInWei,\n            coordinatorCommissionPercentage: period.coordinatorCommissionPercentage,\n            prizePercentage: period.prizePercentage,\n            roundsCount: period.rounds.length,\n            dueWinnersCount: period.dueWinners.length\n        });\n    }\n}\n"},"src/libraries/ArisanProposals.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {Proposal, ProposalCategory, ApprovalStatus} from \"../types/ArisanTypes.sol\";\nimport {ArisanErrors} from \"../errors/ArisanErrors.sol\";\n\n/// @title ArisanProposals\n/// @notice Library for managing governance proposals\n\nlibrary ArisanProposals {\n    // ========== Types ==========\n\n    /// @notice Proposal management state\n    struct ProposalsState {\n        Proposal[] proposals;\n        mapping(uint256 => bool) incompleteProposals;\n        mapping(uint256 => mapping(address => ApprovalStatus)) proposalApprovals;\n    }\n\n    // ========== View Functions ==========\n\n    /// @notice Get total proposals count\n    /// @param state The proposals state\n    /// @return Number of proposals\n    function getProposalsCount(ProposalsState storage state) internal view returns (uint256) {\n        return state.proposals.length;\n    }\n\n    /// @notice Check if proposal exists\n    /// @param state The proposals state\n    /// @param proposalIndex Index of the proposal\n    /// @return True if the proposal exists\n    function proposalExists(ProposalsState storage state, uint256 proposalIndex)\n        internal\n        view\n        returns (bool)\n    {\n        return proposalIndex < state.proposals.length;\n    }\n\n    /// @notice Check if proposal is incomplete\n    /// @param state The proposals state\n    /// @param proposalIndex Index of the proposal\n    /// @return True if the proposal is incomplete\n    function isIncompleteProposal(ProposalsState storage state, uint256 proposalIndex)\n        internal\n        view\n        returns (bool)\n    {\n        return proposalExists(state, proposalIndex) && state.incompleteProposals[proposalIndex];\n    }\n\n    /// @notice Get incomplete proposals count\n    /// @param state The proposals state\n    /// @return Count of incomplete proposals\n    function getIncompleteProposalsCount(ProposalsState storage state)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 count = 0;\n        for (uint256 i = 0; i < state.proposals.length; i++) {\n            if (state.incompleteProposals[i]) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    /// @notice Check if a voter has already voted on a proposal\n    /// @param state The proposals state\n    /// @param proposalIndex Index of the proposal\n    /// @param voter Address of the voter\n    /// @return True if they have voted\n    function hasVoted(ProposalsState storage state, uint256 proposalIndex, address voter)\n        internal\n        view\n        returns (bool)\n    {\n        return state.proposalApprovals[proposalIndex][voter] != ApprovalStatus.Unset;\n    }\n\n    /// @notice Get proposal by index\n    /// @param state The proposals state\n    /// @param proposalIndex Index of the proposal\n    /// @return Proposal storage reference\n    function getProposal(ProposalsState storage state, uint256 proposalIndex)\n        internal\n        view\n        returns (Proposal storage)\n    {\n        if (!proposalExists(state, proposalIndex)) revert ArisanErrors.ProposalDoesNotExist();\n        return state.proposals[proposalIndex];\n    }\n\n    /// @notice Get proposal approvers\n    /// @param state The proposals state\n    /// @param proposalIndex Index of the proposal\n    /// @return Array of approver addresses\n    function getApprovers(ProposalsState storage state, uint256 proposalIndex)\n        internal\n        view\n        returns (address[] memory)\n    {\n        if (!proposalExists(state, proposalIndex)) revert ArisanErrors.ProposalDoesNotExist();\n        return state.proposals[proposalIndex].approvers;\n    }\n\n    /// @notice Get approvers count\n    /// @param state The proposals state\n    /// @param proposalIndex Index of the proposal\n    /// @return Number of approvers\n    function getApproversCount(ProposalsState storage state, uint256 proposalIndex)\n        internal\n        view\n        returns (uint256)\n    {\n        if (!proposalExists(state, proposalIndex)) revert ArisanErrors.ProposalDoesNotExist();\n        return state.proposals[proposalIndex].approvers.length;\n    }\n\n    /// @notice Get approver by index\n    /// @param state The proposals state\n    /// @param proposalIndex Index of the proposal\n    /// @param approverIndex Index in the approvers array\n    /// @return Address of the approver\n    function getApproverByIndex(\n        ProposalsState storage state,\n        uint256 proposalIndex,\n        uint256 approverIndex\n    ) internal view returns (address) {\n        if (!proposalExists(state, proposalIndex)) revert ArisanErrors.ProposalDoesNotExist();\n        if (approverIndex >= state.proposals[proposalIndex].approvers.length)\n            revert ArisanErrors.ProposalDoesNotExist();\n        return state.proposals[proposalIndex].approvers[approverIndex];\n    }\n\n    // ========== Modification Functions ==========\n\n    /// @notice Create a new proposal\n    /// @param state The proposals state\n    /// @param category Category of the proposal\n    /// @param proposer Address of the proposer\n    /// @return proposalIndex Index of the new proposal\n    function createProposal(\n        ProposalsState storage state,\n        ProposalCategory category,\n        address proposer\n    ) internal returns (uint256) {\n        uint256 proposalIndex = state.proposals.length;\n        \n        state.proposals.push(\n            Proposal({\n                category: category,\n                proposedAt: block.timestamp,\n                proposer: proposer,\n                completedAt: 0,\n                isApproved: false,\n                approvers: new address[](0)\n            })\n        );\n        state.incompleteProposals[proposalIndex] = true;\n        return proposalIndex;\n    }\n\n    /// @notice Record a vote on a proposal\n    /// @param state The proposals state\n    /// @param proposalIndex Index of the proposal\n    /// @param voter Address of the voter\n    /// @param approve True if approving, false if rejecting\n    /// @return isNowApproved True if proposal was just approved by this vote\n    function recordVote(\n        ProposalsState storage state,\n        uint256 proposalIndex,\n        address voter,\n        bool approve,\n        uint256 requiredApprovals\n    ) internal returns (bool isNowApproved) {\n        if (!proposalExists(state, proposalIndex)) revert ArisanErrors.ProposalDoesNotExist();\n        if (state.proposals[proposalIndex].completedAt != 0)\n            revert ArisanErrors.ProposalAlreadyCompleted();\n        if (hasVoted(state, proposalIndex, voter)) revert ArisanErrors.AlreadyVotedOnProposal();\n\n        Proposal storage proposal = state.proposals[proposalIndex];\n\n        if (approve) {\n            state.proposalApprovals[proposalIndex][voter] = ApprovalStatus.Approved;\n            proposal.approvers.push(voter);\n\n            // Check if proposal is now approved\n            if (proposal.approvers.length >= requiredApprovals) {\n                proposal.isApproved = true;\n                proposal.completedAt = block.timestamp;\n                state.incompleteProposals[proposalIndex] = false;\n                return true;\n            }\n        } else {\n            state.proposalApprovals[proposalIndex][voter] = ApprovalStatus.Rejected;\n            proposal.completedAt = block.timestamp;\n            state.incompleteProposals[proposalIndex] = false;\n        }\n\n        return false;\n    }\n\n    /// @notice Mark a proposal as completed and rejected\n    /// @param state The proposals state\n    /// @param proposalIndex Index of the proposal\n    function rejectProposal(ProposalsState storage state, uint256 proposalIndex) internal {\n        if (!proposalExists(state, proposalIndex)) revert ArisanErrors.ProposalDoesNotExist();\n        if (state.proposals[proposalIndex].completedAt != 0)\n            revert ArisanErrors.ProposalAlreadyCompleted();\n\n        state.proposals[proposalIndex].completedAt = block.timestamp;\n        state.incompleteProposals[proposalIndex] = false;\n    }\n\n    /// @notice Clean up proposal data mappings\n    /// @param state The proposals state\n    /// @param proposalIndex Index of the proposal\n    /// @dev Called after proposal completion to free storage\n    function cleanupProposal(ProposalsState storage state, uint256 proposalIndex) internal view {\n        if (!proposalExists(state, proposalIndex)) revert ArisanErrors.ProposalDoesNotExist();\n        // Data remains but marked as incomplete = false\n        // External cleanup of proposal-specific mappings should be done in main contract\n    }\n}\n"},"src/libraries/ArisanFinance.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {ArisanErrors} from \"../errors/ArisanErrors.sol\";\nimport {ArisanPlatformFee} from \"./ArisanPlatformFee.sol\";\n\n/// @title ArisanFinance\n/// @notice Library for financial calculations and transfers\n\nlibrary ArisanFinance {\n    // ========== Constants ==========\n\n    uint256 private constant PERCENTAGE_BASE = 100;\n    uint256 private constant MAX_PERCENTAGE = 100;\n\n    // ========== View Functions ==========\n\n    /// @notice Calculate prize amount for a winner\n    /// @param totalContributions Total contributions in the round\n    /// @param prizePercentage Prize percentage\n    /// @return Prize amount in wei\n    function calculatePrize(uint256 totalContributions, uint256 prizePercentage)\n        internal\n        pure\n        returns (uint256)\n    {\n        return (totalContributions * prizePercentage) / PERCENTAGE_BASE;\n    }\n\n    /// @notice Calculate coordinator commission\n    /// @param totalContributions Total contributions in the round\n    /// @param commissionPercentage Commission percentage\n    /// @return Commission amount in wei\n    function calculateCommission(uint256 totalContributions, uint256 commissionPercentage)\n        internal\n        pure\n        returns (uint256)\n    {\n        return (totalContributions * commissionPercentage) / PERCENTAGE_BASE;\n    }\n\n    /// @notice Calculate total payout (prize + commission)\n    /// @param totalContributions Total contributions in the round\n    /// @param prizePercentage Prize percentage\n    /// @param commissionPercentage Commission percentage\n    /// @return Total payout amount\n    function calculateTotalPayout(\n        uint256 totalContributions,\n        uint256 prizePercentage,\n        uint256 commissionPercentage\n    ) internal pure returns (uint256) {\n        return calculatePrize(totalContributions, prizePercentage)\n            + calculateCommission(totalContributions, commissionPercentage);\n    }\n\n    /// @notice Validate percentages\n    /// @param prizePercentage Prize percentage\n    /// @param commissionPercentage Commission percentage\n    function validatePercentages(uint256 prizePercentage, uint256 commissionPercentage)\n        internal\n        pure\n    {\n        if (prizePercentage > MAX_PERCENTAGE) revert ArisanErrors.PrizePercentageTooHigh();\n        if (commissionPercentage > MAX_PERCENTAGE) revert ArisanErrors.CommissionPercentageTooHigh();\n        if (prizePercentage + commissionPercentage > MAX_PERCENTAGE) {\n            revert ArisanErrors.PercentagesSumExceeds100();\n        }\n    }\n\n    /// @notice Check if sufficient balance is available for transfer\n    /// @param currentBalance Current contract balance\n    /// @param lockedBalance Balance locked in ongoing period\n    /// @param requestedAmount Amount requested to transfer\n    /// @return True if sufficient balance available\n    function hasSufficientBalance(\n        uint256 currentBalance,\n        uint256 lockedBalance,\n        uint256 requestedAmount\n    ) internal pure returns (bool) {\n        return currentBalance >= lockedBalance + requestedAmount;\n    }\n\n    /// @notice Calculate available balance for transfers\n    /// @param currentBalance Current contract balance\n    /// @param lockedBalance Balance locked in ongoing period\n    /// @return Available balance\n    function getAvailableBalance(uint256 currentBalance, uint256 lockedBalance)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (currentBalance <= lockedBalance) {\n            return 0;\n        }\n        return currentBalance - lockedBalance;\n    }\n\n    /// @notice Calculate contribution amount for a participant\n    /// @param baseContributionAmount Base contribution amount\n    /// @param roundsSinceLast Number of rounds since last contribution\n    /// @return Total contribution amount due\n    function calculateContributionAmount(uint256 baseContributionAmount, uint256 roundsSinceLast)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (roundsSinceLast == 0) return 0;\n        return baseContributionAmount * roundsSinceLast;\n    }\n\n    // ========== Transfer Functions ==========\n\n    /// @notice Transfer ETH to a recipient\n    /// @param recipient Address to receive the funds\n    /// @param amount Amount to transfer\n    function transfer(address payable recipient, uint256 amount) internal {\n        if (recipient == address(0)) revert ArisanErrors.InvalidRecipient();\n        if (amount == 0) revert ArisanErrors.AmountIsZero();\n\n        (bool success,) = recipient.call{value: amount}(\"\");\n        if (!success) revert ArisanErrors.TransferFailed();\n    }\n\n    /// @notice Batch transfer to multiple recipients\n    /// @param recipients Array of recipient addresses\n    /// @param amounts Array of amounts to transfer\n    function batchTransfer(address payable[] calldata recipients, uint256[] calldata amounts)\n        internal\n    {\n        if (recipients.length != amounts.length) revert ArisanErrors.InvalidParameters();\n        if (recipients.length == 0) revert ArisanErrors.InvalidParameters();\n\n        for (uint256 i = 0; i < recipients.length; i++) {\n            transfer(recipients[i], amounts[i]);\n        }\n    }\n\n    /// @notice Split coordinator commission into net payout and platform fee\n    /// @param coordinatorCommission Gross commission amount\n    /// @return netPayout Coordinator net payout (after platform fee)\n    /// @return platformFee Fee amount for platform wallet\n    function splitCoordinatorCommission(uint256 coordinatorCommission) \n        internal \n        pure \n        returns (uint256 netPayout, uint256 platformFee) \n    {\n        platformFee = ArisanPlatformFee.calculatePlatformFee(coordinatorCommission);\n        netPayout = coordinatorCommission - platformFee;\n    }\n\n    /// @notice Validate coordinator commission percentage\n    /// @param commissionPercentage Commission percentage to validate\n    function validateCoordinatorCommission(uint256 commissionPercentage) internal pure {\n        ArisanPlatformFee.validateCoordinatorCommission(commissionPercentage);\n    }\n}\n"},"src/libraries/ArisanCapacity.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {ArisanErrors} from \"../errors/ArisanErrors.sol\";\n\n/// @title ArisanCapacity\n/// @notice Library for managing group capacity upgrades with incremental payments\n/// @dev Handles infinite expansion after 200 mark with 200-unit increments\nlibrary ArisanCapacity {\n    // ========== Constants ==========\n    \n    /// @notice Initial group capacity\n    uint256 public constant INITIAL_CAPACITY = 10;\n    \n    /// @notice First upgrade target\n    uint256 public constant FIRST_TIER = 50;\n    \n    /// @notice Second upgrade target\n    uint256 public constant SECOND_TIER = 100;\n    \n    /// @notice Third upgrade target and beginning of unlimited tiers\n    uint256 public constant THIRD_TIER = 200;\n    \n    /// @notice Increment size for capacities above THIRD_TIER\n    uint256 public constant UNLIMITED_INCREMENT = 200;\n    \n    // ========== Types ==========\n    \n    /// @notice Capacity management state\n    struct CapacityState {\n        uint256 currentCapacity;\n        uint256 upgradeCount;\n    }\n    \n    // ========== View Functions ==========\n    \n    /// @notice Get available member slots\n    /// @param state The capacity state\n    /// @param currentMemberCount Current number of members\n    /// @return Number of available slots\n    function getAvailableCapacity(\n        CapacityState storage state,\n        uint256 currentMemberCount\n    ) internal view returns (uint256) {\n        if (currentMemberCount >= state.currentCapacity) {\n            return 0;\n        }\n        return state.currentCapacity - currentMemberCount;\n    }\n    \n    /// @notice Calculate next capacity tier after upgrade\n    /// @param currentCapacity Current capacity limit\n    /// @return Next capacity tier\n    function getNextCapacity(uint256 currentCapacity) internal pure returns (uint256) {\n        if (currentCapacity == INITIAL_CAPACITY) {\n            return FIRST_TIER;\n        } else if (currentCapacity == FIRST_TIER) {\n            return SECOND_TIER;\n        } else if (currentCapacity == SECOND_TIER) {\n            return THIRD_TIER;\n        } else if (currentCapacity >= THIRD_TIER) {\n            // Infinite expansion: add INCREMENT to current capacity\n            return currentCapacity + UNLIMITED_INCREMENT;\n        }\n        \n        revert ArisanErrors.InvalidParameters();\n    }\n    \n    /// @notice Check if current capacity can be upgraded\n    /// @param currentCapacity Current capacity\n    /// @param currentMemberCount Current member count\n    /// @return True if upgrade is possible\n    function canUpgrade(uint256 currentCapacity, uint256 currentMemberCount) \n        internal \n        pure \n        returns (bool) \n    {\n        // Cannot upgrade if already at or above member count\n        uint256 nextCapacity = getNextCapacity(currentCapacity);\n        return currentMemberCount < nextCapacity;\n    }\n    \n    // ========== State Modification ==========\n    \n    /// @notice Perform capacity upgrade\n    /// @param state The capacity state\n    /// @param currentMemberCount Current member count (for validation)\n    function performUpgrade(CapacityState storage state, uint256 currentMemberCount) internal {\n        require(canUpgrade(state.currentCapacity, currentMemberCount), \"Cannot upgrade at current member count\");\n        \n        state.currentCapacity = getNextCapacity(state.currentCapacity);\n        state.upgradeCount += 1;\n    }\n    \n    /// @notice Initialize capacity state\n    /// @param state The capacity state\n    function initialize(CapacityState storage state) internal {\n        state.currentCapacity = INITIAL_CAPACITY;\n        state.upgradeCount = 0;\n    }\n}"},"src/libraries/ArisanPlatformFee.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {ArisanErrors} from \"../errors/ArisanErrors.sol\";\n\n/// @title ArisanPlatformFee\n/// @notice Library for managing platform fee collection on coordinator commissions\n/// @dev Hardcoded, immutable platform fee ensures transparency and fairness\nlibrary ArisanPlatformFee {\n    // ========== Constants ==========\n    \n    /// @notice Platform fee percentage (5% of coordinator commission)\n    /// @dev Immutable and hardcoded - only changeable via new contract deployment\n    uint256 public constant PLATFORM_FEE_PERCENTAGE = 5;\n    \n    /// @notice Percentage base for calculations\n    uint256 private constant PERCENTAGE_BASE = 100;\n    \n    // ========== View Functions ==========\n    \n    /// @notice Calculate platform fee from coordinator commission\n    /// @param coordinatorCommission Amount of coordinator commission\n    /// @return Platform fee amount (5% of coordinator commission)\n    function calculatePlatformFee(uint256 coordinatorCommission) \n        internal \n        pure \n        returns (uint256) \n    {\n        return (coordinatorCommission * PLATFORM_FEE_PERCENTAGE) / PERCENTAGE_BASE;\n    }\n    \n    /// @notice Calculate coordinator net payout after platform fee deduction\n    /// @param coordinatorCommission Gross coordinator commission\n    /// @return Net amount coordinator receives\n    function calculateCoordinatorNetPayout(uint256 coordinatorCommission) \n        internal \n        pure \n        returns (uint256) \n    {\n        uint256 platformFee = calculatePlatformFee(coordinatorCommission);\n        return coordinatorCommission - platformFee;\n    }\n    \n    /// @notice Validate coordinator commission constraints\n    /// @param commissionPercentage Coordinator commission percentage\n    function validateCoordinatorCommission(uint256 commissionPercentage) internal pure {\n        if (commissionPercentage < 5) {\n            revert ArisanErrors.CommissionTooLow();\n        }\n        if (commissionPercentage > 50) {\n            revert ArisanErrors.CommissionPercentageTooHigh();\n        }\n    }\n}"}},"settings":{"remappings":["@openzeppelin-contracts-5.5.0/=dependencies/@openzeppelin-contracts-5.5.0/","forge-std-1.11.0/=dependencies/forge-std-1.11.0/","forge-std/=lib/forge-std/src/"],"optimizer":{"enabled":true,"runs":500},"metadata":{"useLiteralContent":false,"bytecodeHash":"ipfs","appendCBOR":true},"outputSelection":{"*":{"*":["abi","evm.bytecode.object","evm.bytecode.sourceMap","evm.bytecode.linkReferences","evm.deployedBytecode.object","evm.deployedBytecode.sourceMap","evm.deployedBytecode.linkReferences","evm.deployedBytecode.immutableReferences","evm.methodIdentifiers","metadata"]}},"evmVersion":"prague","viaIR":true,"libraries":{}}}
